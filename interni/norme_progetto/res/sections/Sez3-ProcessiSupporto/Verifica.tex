\subsection{Verifica}

    \subsubsection{Scopo}
    
    Il processo di verifica ha lo scopo di stabilire se il prodotto è realizzato nel modo corretto secondo delle regole stabilite.
    
    \subsubsection{Aspettative}
    
    Lo svolgimento del processo di verifica sarà garantito seguendo determinati punti:
    
    \begin{itemize}
        \item definizione di criteri di accettazione;
	\item prescrizione delle attività di verifica con relativa documentazione;
	\item test di verifica;
	\item correzione di eventuali \glock{difetti}.
    \end{itemize}
    
    \subsubsection{Descrizione}
		La verifica consiste nel cercare e risolvere possibili \textit{difetti} all'interno della documentazione e del codice prodotto. Il completamento del processo di verifica rende possibile l'esecuzione del processo di validazione.

    \subsubsection{Attività}
        \paragraph{Analisi statica e dinamica}
            \subparagraph{Analisi statica}\mbox{}\\
                L'analisi statica viene effettuata sul prodotto senza necessità di eseguirlo e serve per verificare che non ci siano errori o \textit{difetti}. I due tipi di analisi statica sono:
                \begin{itemize}
                    \item \textbf{walkthrough:} consiste nell'analizzare i vari documenti e file in tutto il loro contenuto per trovare eventuali \textit{difetti}. Il verificatore controlla se sono presenti \textit{difetti} e, in caso ne trovi, la correzione verrà effettuata dagli sviluppatori; 
                    \item \textbf{inspection:} in questa tecnica è noto a priori dove debbano essere ricercati i possibili \textit{difetti} del prodotto, quindi non si analizzano i documenti e file per intero, ma solo le parti in cui di solito sono presenti. Il verificatore compone una lista di controllo (checklist) inserendo i punti in cui si possono rilevare possibili \textit{difetti}, controlla in quei punti della lista e, se trova delle incorrettezze, la correzione viene poi effettuata dagli sviluppatori. \\
			Di seguito alcuni possibili punti in cui trovare \textit{difetti} all'interno della documentazione:
			\begin{itemize}
				\item elenchi puntati;
				\item formato date;
				\item parole/frasi in grassetto/corsivo;
				\item uso di riferimenti appropriati al glossario/documento.
			\end{itemize}
                \end{itemize}
            \subparagraph{Analisi dinamica}\mbox{}\\
                L'analisi dinamica è una tecnica per cui è necessaria l'esecuzione dell'oggetto di verifica, e consiste nell'attività di test.

            \paragraph{Test}
    			I test fanno parte dell'attività di analisi dinamica e servono per individuare possibili errori di funzionamento del codice. Per effettuare i test, essi devono essere automatizzati, tramite strumenti appositi, e ripetibili, ovvero devono essere definiti:
    			\begin{itemize}
    				\item l'ambiente di sviluppo e lo stato iniziale;
    				\item le istruzioni eseguite;
    				\item i dati di input e i dati di output attesi.
    			\end{itemize}

                Per elencare le specifiche dei test si è scelta una rappresentazione tabellare contenente il codice del componente da testare, la descrizione dei test, il suo stato di avanzamento e il risultato del test stesso secondo la seguente nomenclatura: \\
                Stato:
                \begin{itemize}
                    \item \textbf{I:} il test è stato implementato;
                    \item \textbf{NI:} il test non è ancora stato implementato.     
                \end{itemize}
                Risultato:
                \begin{itemize}
                    \item \textbf{S:} il test ha successo;
                    \item \textbf{F:} il test ha fallito.
                \end{itemize}
                Tuttavia si è scelto di omettere il risultato dei test in quanto non significativo allo stato attuale del prodotto.


            \subparagraph*{Test di sistema}
                Dopo aver eseguito i test su tutte le unità e sulla loro integrazione, si testa il sistema nella sua interezza. Viene testato se le interazioni tra le varie componenti del sistema ritornano il risultato atteso o meno in concordanza con ciò che è stato definito nel processo di analisi dei requisiti.
                Per classificare questa tipologia di test si utilizzerà un codice utilizzando il seguente modello:     

                \begin{center}
                	\textbf{TS[Priorità]-[Tipologia]-[Identificativo]}
                \end{center}
                Dove: 
                
                \begin{itemize}
	                \item \textbf{Priorità:} indica la priorità del requisito associato al test e potrà avere i seguenti valori:
		                \begin{itemize}
		                    \item \textbf{A:} obbligatorio, strettamente necessario;
		                    \item \textbf{B:} desiderabile, non strettamente necessario;
		                    \item \textbf{C:} relativamente utile o contrattabile in corso d'opera. 
		                 \end{itemize} 
	                 \item \textbf{Tipologia:} indica la tipologia del requisito associato al test e potrà avere i seguenti valori:
		                 \begin{itemize}
		                    \item \textbf{F:} funzionale;
		                    \item \textbf{P:} prestazionale;
		                    \item \textbf{Q:} qualitativo;
		                    \item \textbf{V:} vincolo.
		                 \end{itemize}
	                \item \textbf{Identificativo:} numero progressivo il cui obiettivo sarà di contraddistinguere il singolo componente da testare; parte da 1.
                \end{itemize}

                 \subparagraph*{Test di integrazione}
        			Test eseguiti su componenti del software per verificare se l'insieme di unità si interfaccia come dovrebbe. Questo test è eseguito in modo ricorrente: ogni volta che un insieme di unità esegue correttamente, esso viene integrato con altri insiemi di unità, fino al test completo sul sistema.
                    Per classificare questa tipologia di test si utilizzerà un codice utilizzando il seguente modello:     

                        \begin{center}
                        	\textbf{TI-[Identificativo]}
                        \end{center}
                        Dove:
                        
						\begin{itemize}
                       		\item \textbf{Identificativo:} è un numero progressivo il cui obiettivo sarà di contraddistinguere il singolo componente da testare; parte da 1.
						\end{itemize}
					
                    \subparagraph*{Test di unità}
                            Test eseguiti sul funzionamento di unità di software in modo automatico: viene definito l'input e l'output atteso per verificare il corretto funzionamento dell'unità.
                            Per classificare questa tipologia di test si utilizzerà un codice secondo il seguente modello:     

                            \begin{center}
                            	\textbf{TU-[Identificativo]}
                            \end{center}
                            Dove:
                            
							\begin{itemize}
                            	\item \textbf{Identificativo:} è un numero progressivo il cui obiettivo sarà di contraddistinguere il singolo componente da testare; parte da 1.
							\end{itemize}
						
                    \subparagraph*{Test di regressione}
        				Test eseguito ogni volta che un'unità viene modificata allo scopo di trovare \textit{difetti} nelle funzionalità già testate, potendo garantire che le funzionalità preesistenti non abbiano cambiato comportamento. Si rieseguono tutti i test necessari affinché si possa essere certi che la modifica non causi il funzionamento scorretto di altre unità collegate all'unità modificata.


                \subsubsection{Metriche}

                Per il processo di verifica non sono state ancora definite e implementate delle metriche di qualità.

                %\paragraph{QP-4 Verifica}

                %    \subparagraph{Scopo}

                 %       Durante tutta la fase di sviluppo, si vuole monitorare il processo di verifica (software) mettendo in luce aspetti che riguardano la complessità e la copertura di test a livello di codice. Questo può essere utile per il cliente e per il gruppo per comprendere l'avanzamento delle attività di verifica del software fino alla data attuale.

                  %  \subparagraph{Introduzione alle Metriche}

                   %      Per la Verifica del Software si farà uso delle seguenti metriche:

                    %    \begin{itemize}

                     %       \item QM-PROC-10. Branch Coverage (BCOV);
                      %      \item QM-PROC-11. Condition Coverage (COCOV);
                       %     \item QM-PROC-12. Statement Coverage (SCOV);
                       %     \item QM-TEST-13. Passed Test Cases Percentage (PTCP);
                        %    \item QM-TEST-14. Failed Test Cases Percentage (FTCP);
                         %   \item QM-TEST-15. Bug-Fixing Percentage (BFP);
                          %  \item QM-TEST-16. Test Effectiveness (TE).
                        %\end{itemize}

                    %\subparagraph{QM-PROC-10. Branch Coverage (BCOV)}

                    %\begin{itemize}
                        
                     %   \item \textbf{descrizione: }
                      %      La metrica BC viene utilizzata per assicurare l'esecuzione di ogni possibile ramo (branch) decisionale del programma almeno una volta. Questo permette di comprendere quali rami decisionali non vengono effettivamente eseguiti e testati.

                       % \item \textbf{unità di misura: }
                       % La metrica viene espressa in percentuale.

                      %  \item \textbf{formula: }
                       %     La formula della metrica è la seguente:
                       %     \[
                       %         \text{BCOV} = \frac{\text{Numero di rami eseguiti}}{\text{Numero totale di rami}} \times 100
                      %      \]

                       % \item \textbf{risultato: }
                        %\begin{itemize}
                        %    \item Se il risultato è pari a 0\%, la copertura è nulla.
                            %\item Se il risultato è pari al 100\%, la copertura è totale.
                            %\item Se il risultato è maggiore di 0\%, ma minore di 100\%, la copertura è parziale.
                        %\end{itemize}
                    %\end{itemize}

                %\subparagraph{QM-PROC-11. Condition Coverage (COCOV)}
                 %   \begin{itemize}
                  %  \item \textbf{descrizione: }
                   %     La metrica CC verifica che ogni condizione di tipo booleano realizzata con gli operatori logici venga considerata sia vera che falsa. Questo permette di avere una migliore sensibilità sul controllo di flusso del programma.

                    %\item \textbf{unità di misura: }
                   % La metrica viene espressa in percentuale.

                    %\item \textbf{formula: }
                    %La formula della metrica è la seguente:
                    %\[
                    %    \text{COCOV} = \frac{\text{Numero di operandi eseguiti}}{\text{Numero totale di operandi}} \times 100
                    %\]

                    %\item \textbf{risultato: }
                    %\begin{itemize}
                     %   \item Se il risultato è pari a 0\%, la copertura è nulla.
                     %   \item Se il risultato è pari al 100\%, la copertura è totale.
                      %  \item Se il risultato è maggiore di 0\%, ma minore di 100\%, la copertura è parziale.
                    %\end{itemize}
          %  \end{itemize}

           % \subparagraph{QM-PROC-12. Statement Coverage (SCOV)}
            %\begin{itemize}
             %   \item \textbf{descrizione: }
              %  La metrica SC viene utilizzata per calcolare e misurare il numero di statement che possono essere eseguiti, posto un determinato input. L'obiettivo è quello di riuscire a coprire tramite i test il maggior numero di statement, rispetto a quelli totali.

            %    \item \textbf{unità di misura: }
            %    La metrica viene espressa in percentuale.

             %   \item \textbf{formula: }
             %   La formula della metrica è la seguente:
             %   \[
             %       \text{SCOV} = \frac{\text{Numero di statement eseguiti}}{\text{Numero totale di statement}} \times 100
             %   \]

            %    \item \textbf{risultato: }
            %    \begin{itemize}
            %        \item Se il risultato è pari a 0\%, la copertura è nulla.
            %        \item Se il risultato è pari al 100\%, la copertura è totale.
            %        \item Se il risultato è maggiore di 0\%, ma minore di 100\%, la copertura è parziale.
            %    \end{itemize}
            %\end{itemize}

           % \subparagraph{QM-TEST-1. Passed Test Cases Percentage (PTCP)}
           % \begin{itemize}
             %   \item \textbf{descrizione: }
             %   La metrica PTCP si utilizza per misurare la percentuale di test passati con successo in una specifica fase del progetto fino alla data corrente.

            %    \item \textbf{unità di misura: }
            %    La metrica viene espressa in percentuale.

            %    \item \textbf{formula: }
            %    La formula della metrica è la seguente:
            %    \[
            %        \text{PTCP} = \frac{\text{Numero di test passati}}{\text{Numero totale di test eseguiti}} \times 100
            %    \]

            %    \item \textbf{risultato: }
            %    \begin{itemize}
            %        \item Se il risultato è pari a 0\%, nessun test realizzato per il software è andato a buon fine;
             %       \item Se il risultato è pari al 100\%, tutti i test realizzati per il software sono andati a buon fine;
            %        \item Se il risultato è compreso tra 0\% e 100\%, non tutti i test realizzati per il software sono andati a buon fine.
             %   \end{itemize}
            %\end{itemize}

            %\subparagraph{QM-TEST-2. Failed Test Cases Percentage (FTCP)}
            %\begin{itemize}
            %    \item \textbf{descrizione: }
            %    La metrica FTCP viene usata per misurare la percentuale di test falliti in una specifica fase del progetto fino alla data corrente.

             %   \item \textbf{unità di misura: }
            %    La metrica viene espressa in percentuale.

            %    \item \textbf{formula: }
            %    La formula della metrica è la seguente:
            %    \[
            %        \text{FTCP} = \frac{\text{Numero di test falliti}}{\text{Numero totale di test eseguiti}} \times 100
            %    \]

             %   \item \textbf{risultato: }
             %   \begin{itemize}
             %       \item Se il risultato è pari a 0\%, non ci sono test realizzati per il software che sono falliti;
             %       \item Se il risultato è pari al 100\%, tutti i test realizzati per il software sono falliti;
              %      \item Se il risultato è compreso tra 0\% e 100\%, non tutti i test realizzati per il software sono andati a buon fine.
              %  \end{itemize}
           % \end{itemize}

           % \subparagraph{QM-TEST-3. Bug-Fixing Percentage (BFP)}
           % \begin{itemize}
            %    \item \textbf{descrizione: }
            %    La metrica BFP si utilizza per misurare il quantitativo di errori corretti nel codice rispetto agli errori trovati fino alla data corrente.

            %    \item \textbf{unità di misura: }
            %    La metrica viene espressa in percentuale.

             %   \item \textbf{formula: }
             %   La formula della metrica è la seguente:
             %   \[
            %        \text{BFP} = \frac{\text{Numero di difetti corretti}}{\text{Numero di difetti trovati}} \times 100
             %   \]

             %   \item \textbf{risultato: }
             %   \begin{itemize}
             %       \item Se il risultato è pari a 0\%, nessun difetto è stato risolto;
             %       \item Se il risultato è pari al 100\%, tutti i difetti sono stati risolti;
             %       \item Se il risultato è compreso tra 0\% e 100\%, non tutti i difetti sono stati corretti.
             %   \end{itemize}
            %\end{itemize}

           % \subparagraph{QM-TEST-4. Test Effectiveness (TE)}
           % \begin{itemize}
              %  \item \textbf{descrizione: }
              %  La metrica TE si utilizza per misurare l'efficacia con cui si trovano dei difetti attraverso i test.

              %  \item \textbf{unità di misura: }
              %  La metrica viene espressa in percentuale.

             %   \item \textbf{formula: }
             %   La formula della metrica è la seguente:
              %  \[
              %      \text{TE} = \frac{\text{Difetti trovati con i test}}{\text{Numero totale di difetti trovati}} \times 100
             %   \]

               % \item \textbf{risultato: }
               % \begin{itemize}
              %      \item Se il risultato è pari a 0\%, nessun difetto è stato risolto;
              %      \item Se il risultato è pari al 100\%, tutti i difetti sono stati risolti;
              %      \item Se il risultato è compreso tra 0\% e 100\%, non tutti i difetti sono stati corretti.
             %   \end{itemize}  
           % \end{itemize}       

        \subsubsection{Strumenti}

            \paragraph{Programmi per il controllo ortografico}

                \subparagraph{TeXstudio}
                	È stato utilizzato il correttore ortografico integrato nell'\glock{ide} TeXstudio, utilizzato per la redazione della documentazione.

                \subparagraph{Sublime Text}
                    Si fa uso dello \textit{spell checker}, in lingua italiana, per la verifica degli errori ortografici nella documentazione di progetto.

            \paragraph{Analisi statica del codice}

                \subparagraph{Checkstyle}

	                \begin{itemize}
	                    \item \textbf{componenti software:} swe-api, swe-kafka-db, swe-gateway;
	                    \item \textbf{linguaggio:} Java.
	                \end{itemize}
	                
	                Checkstyle è un plugin, che viene integrato dal gestore di dipendenze \textit{maven}, per eseguire automaticamente i controlli di verifica di regole sintattiche per codice Java.
	                \newline
	                Permette di essere configurato direttamente da un file XML presente nella cartella di progetto, denominato \textit{checkstyle.xml}, contenente tutte le regole da verificare. In particolare:
	                \begin{itemize}
	                    \item ad ogni build viene eseguita l'analisi statica e vengono segnalati tutti gli errori trovati, tramite degli opportuni warning;
	                    \item permette di far rispettare lo standard di codifica adottato;
	                    \item il file \textit{checkstyle.xml} deve essere versionato.
	                \end{itemize}

                \subparagraph{Prettier}

	                \begin{itemize}
	                    \item \textbf{componenti software:} swe-telegram, swe-webapp;
	                    \item \textbf{linguaggio:} JavaScript, Vue.js.
	                \end{itemize}
	                
	                Prettier è uno strumento per il controllo automatico della formattazione del codice scritto in linguaggio JavaScript, esso permette di eseguire dei controlli sul formato del codice, tramite delle regole configurabili.
	                \newline
	                Oltre ad effettuare il controllo, mette a disposizione anche una funzionalità di riformattazione automatica del codice, attivabile al momento del salvataggio del file modificato; in questo modo facilità l'aderenza allo stile di codifica da parte dei programmatori.
				
				\subparagraph{ESLint} 
				
					\begin{itemize}
						\item \textbf{componenti software:} swe-telegram, swe-webapp;
						\item \textbf{linguaggio:} JavaScript, Vue.js.
					\end{itemize}
					
					ESLint è uno strumento per il controllo di conformità del codice, usato per il linguaggio Javascript, che permette di verificare l'aderenza a delle precise regole sintattiche.
					\newline
					Analogamente a \textit{checkstyle}, permette di eseguire dei controlli simili, attraverso un file di configurazione dove devono essere specificate tutte le regole di codifica che si intendono adottare.
					\newline
					Oltre ad effettuare il controllo, mette a disposizione anche una funzionalità di autocorrezione del codice, in base agli errori rilevati, eseguibile tramite un apposito comando da terminale; in questo modo facilità l'aderenza allo stile di codifica da parte dei programmatori.
					\newline
					Inoltre, attraverso la propria estensione per \textit{Prettier}, è possibile integrare quest'ultimo all'interno di ESLint, in modo da eseguire automaticamente anche i controlli di formattazione del codice e gli eventuali aggiustamenti necessari. In particolare:
					\begin{itemize}
						\item ad ogni commit viene eseguita l'analisi statica e vengono segnalati tutti gli errori trovati, tramite degli opportuni warning;
						\item permette di far rispettare lo standard di codifica adottato;
						\item il file \textit{.eslintrc.json} deve essere versionato.
					\end{itemize}
				
				\subparagraph{PHP_CodeSniffer} 
				
					\begin{itemize}
						\item \textbf{componenti software:} swe-webapp;
						\item \textbf{linguaggio:} PHP.
					\end{itemize}
					
					PHP_CodeSniffer è uno strumento per il controllo di conformità del codice, usato per il linguaggio PHP, che permette di verificare l'aderenza a delle precise regole sintattiche, definite da uno standard di codifica.
					\newline
					Analogamente a \textit{checkstyle}, permette di eseguire dei controlli simili, attraverso un file di configurazione dove devono essere specificate tutte le regole di codifica che si intendono adottare.
					\newline
					Oltre ad effettuare il controllo, mette a disposizione anche una funzionalità di autocorrezione del codice, in base agli errori rilevati, eseguibile tramite un apposito comando da terminale; in questo modo facilità l'aderenza allo stile di codifica da parte dei programmatori.
					\newline
					Tuttavia, per avere una copertura più completa dello standard di codifica definito per PHP, è stato necessario integrare un altro strumento di controllo sintattico che coprisse le regole non verificate da PHP_CodeSniffer. In particolare:
					\begin{itemize}
						\item ad ogni commit viene eseguita l'analisi statica e vengono segnalati tutti gli errori trovati, tramite degli opportuni warning;
						\item permette di far rispettare lo standard di codifica adottato;
						\item il file \textit{.phpcs.xml} deve essere versionato.
					\end{itemize}
				
				\subparagraph{PHP-CS-Fixer} 
					
					\begin{itemize}
						\item \textbf{componenti software:} swe-webapp;
						\item \textbf{linguaggio:} PHP.
					\end{itemize}
					
					PHP-CS-Fixer è uno strumento per il controllo di conformità del codice, usato per il linguaggio PHP, che permette di verificare l'aderenza a delle precise regole sintattiche, definite da uno standard di codifica.
					\newline
					Analogamente a \textit{checkstyle}, permette di eseguire dei controlli simili, attraverso un file di configurazione dove devono essere specificate tutte le regole di codifica che si intendono adottare.
					\newline
					Oltre ad effettuare il controllo, mette a disposizione anche una funzionalità di autocorrezione del codice, in base agli errori rilevati, eseguibile tramite un apposito comando da terminale; in questo modo facilità l'aderenza allo stile di codifica da parte dei programmatori.
					\newline
					Questo strumento è stato affiancato a PHP_CodeSniffer, per avere una copertura più completa dello standard di codifica definito per PHP. In particolare:
					\begin{itemize}
						\item ad ogni commit viene eseguita l'analisi statica e vengono segnalati tutti gli errori trovati, tramite degli opportuni warning;
						\item permette di far rispettare lo standard di codifica adottato;
						\item il file \textit{.php_cs.php} deve essere versionato.
					\end{itemize}
				
				\subparagraph{SonarCloud}
					
					\begin{itemize}
						\item \textbf{componenti software:} swe-api, swe-kafka-db, swe-gateway, swe-swe-telegram, swe-webapp;
						\item \textbf{linguaggio:} tutti.
					\end{itemize}
					
					SonarCloud è un servizio web che permette di eseguire e gestire dei controlli di qualità del codice presente all'interno di un repository e di riportare tutti i risultati delle analisi effettuate in un cruscotto accessibile tramite web.
					\newline
					È possibile integrarlo direttamente all'interno del servizio di versionamento utilizzato per il codice di programmazione; nel nostro caso, risulta completamente integrato con Git e permette di determinare, staticamente, possibili problemi del codice scritto. In particolare:
					\begin{itemize}
						\item può essere utilizzato congiuntamente a Github, in modo da effettuare automaticamente la verifica delle regole impostate per il progetto contenuto all'interno dei repository presenti;
						\item se integrato con Github, permette di eseguire i controlli ad ogni pull request verso il branch principale e di bloccare l'operazione se il nuovo codice non rispetta le regole impostate; 
						\item permette di rilevare potenziali bug, vulnerabilità e \textit{code smells} presenti nel codice, segnalandoli opportunamente all'interno del cruscotto web;
						\item se è stato configurato uno strumento di controllo del \textit{code coverage}, il report effettuato in seguito all'esecuzione di test di unità può essere riportato a cruscotto, assieme ai risultati dell'analisi statica.
					\end{itemize}

                \subparagraph{SonarLint}

	                \begin{itemize}
	                    \item \textbf{componenti software:} swe-api, swe-kafka-db, swe-gateway, swe-swe-telegram, swe-webapp;
	                    \item \textbf{linguaggio:} tutti.
	                \end{itemize}
	
	                SonarLint è un plugin della suite di SonarCloud che permette di eseguire dei controlli di qualità del codice direttamente durante la scrittura. 
	                \newline
	                È possibile installarlo direttamente all'interno dell'IDE in cui si scrive codice di programmazione; nel nostro caso, risulta completamente integrato con tutta la suite di JetBrains (IntelliJ Idea, PHPStorm e WebStorm) e permette di determinare, staticamente, possibili problemi del codice scritto. In particolare:
		            \begin{itemize}
		            	\item può essere utilizzato congiuntamente a SonarCloud, in modo da effettuare automaticamente il bind con le regole impostate, sul servizio web, per il progetto analizzato;
		            	\item permette di rilevare potenziali bug, vulnerabilità e \textit{code smells} presenti nel codice, segnalandoli opportunamente all'interno dell'IDE utilizzato.
		            \end{itemize}
                
		
		\paragraph{Analisi dinamica del codice}
                
