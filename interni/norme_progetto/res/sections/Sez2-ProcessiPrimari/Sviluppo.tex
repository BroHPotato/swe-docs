\subsection{Sviluppo}
		\subsubsection{Scopo}
			Il processo di sviluppo definisce i compiti e le attività da intraprendere per ottenere il prodotto finale richiesto dal proponente.
		\subsubsection{Aspettative}
			Per una corretta implementazione di questo processo è necessario fissare:
				\begin{itemize}
					\item obiettivi di sviluppo;
					\item vincoli tecnologici e di design.
				\end{itemize}
			Il prodotto finale deve rispettare i requisiti e le aspettative del proponente, superando i test definiti dalle norme di qualità.
		\subsubsection{Descrizione}
			Il processo di sviluppo, secondo lo standard ISO/IEC 12207:1995, si articola nelle seguenti attività:
				\begin{itemize}
					\item analisi dei requisiti;
					\item progettazione;
					\item codifica.
				\end{itemize}

		\subsubsection{Attività}
			Di seguito verranno analizzate dettagliatamente le attività menzionate nella sezione precedente.
			\paragraph{Analisi dei requisiti}
				\subparagraph{Scopo}
					Gli analisti si occupano di stilare il documento \dext{Analisi dei Requisiti v1.0.0}, il cui scopo è definire ed elencare tutti i requisiti del capitolato. Il documento finale conterrà:
					\begin{itemize}
						\item descrizione generale del prodotto;
						\item argomentazioni precise ed affidabili per i progettisti;
						\item casi d'uso rappresentati tramite diagrammi UML;
						\item funzionalità e requisiti concordi con le richieste del cliente;
						\item tracciamento dei requisiti individuati.
					\end{itemize}
				\subparagraph{Aspettative}
					Creazione del documento formale contente tutti i requisiti richiesti dal proponente per la realizzazione del capitolato.
				\subparagraph{Classificazione dei Requisiti}
					Al fine di facilitarne la consultazione e comprensione, i requisiti saranno classificati ed identificati univocamente secondo il seguente schema identificativo:
					\begin{center}
						\textbf{R[Priorità]-[Tipologia]-[Identificativo]}
					\end{center}
					Dove:
					\begin{itemize}
						\item \textbf{R:} requisito
						\item \textbf{Priorità:} ogni requisito assumerà uno dei seguenti valori:
						\begin{itemize}
							\item \textbf{A:} obbligatorio, strettamente necessario;
							\item \textbf{B:} desiderabile, non strettamente necessario;
							\item \textbf{C:} opzionale, relativamente utile o contrattabile in corso d'opera.
						\end{itemize}
						\item \textbf{Tipologia:} ogni requisito assumerà uno dei seguenti valori:
						\begin{itemize}
							\item \textbf{F:} funzionale;
							\item \textbf{P:} prestazionale;
							\item \textbf{Q:} qualitativo;
							\item \textbf{V:} vincolo.
						\end{itemize}
						\item \textbf{Identificativo:} numero progressivo per contraddistinguere il requisito, in forma gerarchica padre-figlio strutturato come segue:
						\begin{center}
							\textbf{[codicePadre].[codiceFiglio]}
						\end{center}
					\end{itemize}
				\subparagraph{Classificazione dei casi d'uso}
					Gli analisti, dopo la stesura dei requisiti, hanno anche il compito di identificare ed elencare i casi d'uso. Ognuno di essi è identificato, in maniera univoca, secondo il seguente schema identificativo:
					\begin{center}
						\textbf{UC[codiceCaso].[codiceSottoCaso].[codiceSottoSottoCaso]}
					\end{center}
					Ogni caso d'uso oltre al codice di identificazione deve contenere, integralmente o parzialmente, i seguenti campi:
					\begin{itemize}
						\item \textbf{diagrammi UML:} diagrammi realizzati usando la versione 2.0 del linguaggio;
						\item \textbf{attori primari:} attori principali del caso d'uso;
						\item \textbf{attori secondari:} attori secondari del caso d'uso;
						\item \textbf{descrizione:} breve descrizione del caso d'uso;
						\item \textbf{attori secondari:} attori secondari del caso d'uso;
						\item \textbf{estensioni:} eventuali estensioni coinvolte;
						\item \textbf{inclusioni:} eventuali inclusioni coinvolte;
						\item \textbf{precondizione:} condizioni che devono essere soddisfatte perché si verifichino gli eventi del caso d'uso;
						\item \textbf{post-condizione:} condizioni che devono essere soddisfatte dopo il verificarsi degli eventi del caso d'uso;
						\item \textbf{scenario principale:} flusso degli eventi, in forma di elenco numerato, con eventuale riferimento ad ulteriori casi d'uso.
					\end{itemize}

			\paragraph {Progettazione}
				\subparagraph{Scopo}
					L'attività di progettazione precede quella di codifica ed avviene successivamente all'analisi dei requisiti.
					\newline
					In questa attività i progettisti hanno il compito di definire una soluzione del problema che sia soddisfacente per gli \glock{stakeholder}. 
					\newline
					Lo scopo della progettazione è definire l'architettura logica del prodotto da sviluppare e deve permettere di:
					\begin{itemize}
						\item garantire l'efficacia del prodotto, soddisfacendo tutti i requisiti individuati nell'attività di analisi, attraverso un sistema di qualità che persegua il principio di correttezza per costruzione;
						\item garantire l'efficienza nella realizzazione del prodotto, impiegando parti riusabili con specifiche chiare, organizzate in modo da facilitarne la manutenzione e realizzabili con risorse sostenibili;
						\item gestire la complessità del sistema, suddividendolo fino ad ottenere delle parti di complessità trattabile, che possano essere fornite in ingresso all'attività di codifica come singoli compiti individuali che siano, quindi, fattibili, rapidi e verificabili.
					\end{itemize}
				
				\subparagraph{Aspettative}
					Le aspettative della progettazione è la definizione l'architettura logica del prodotto, la quale dovrà godere delle seguenti qualità:
					\begin{itemize}
						\item \textbf{sufficienza:} capace di soddisfare tutti i requisiti;
						\item \textbf{comprensibilità:} capibile da tutti gli stakeholder;
						\item \textbf{modularità:} suddivisibile in parti chiare e ben distinte, riducendo la dipendenza tra le parti stesse, per ridurre i cambiamenti esterni causati da modifiche interne ad una singola parte;
						\item \textbf{robustezza:} capace di sopportare ingressi diversi da parte dell'utente e dell'ambiente;
						\item \textbf{flessibilità:} modificabile a costo contenuto al variare dei requisiti;
						\item \textbf{efficienza nella gestione delle risorse;}
						\item \textbf{affidabilità:} svolge bene il suo compito, quando utilizzata;
						\item \textbf{disponibilità:} richiede un tempo di indisponibilità limitato o nullo per effettuare la manutenzione;
						\item \textbf{sicurezza:} non presenta malfunzionamenti gravi e non presenta vulnerabilità alle intrusioni;
						\item \textbf{semplicità:} composta di parti contenenti solamente il necessario e nulla di superfluo;
						\item \textbf{incapsulazione:} composta di parti il cui interno non risulta visibile dall'esterno, in modo da ridurre le dipendenze indotte sull'esterno e quindi facilitare la manutenzione;
						\item \textbf{coesione:} composta da parti raggruppate per obiettivi comuni, in modo da ridurre l'interdipendenza tra le componenti e quindi aumentare la manutenibilità e la comprensibilità;
						\item \textbf{basso accoppiamento:} composta da parti distinte che dipendono poco o niente le une dalle altre.
					\end{itemize}
				
				\subparagraph{Descrizione}
					Per perseguire la qualità nella progettazione dell'architettura è necessario seguire le seguenti regole:
					\begin{itemize}
						\item ogni attività svolta deve essere coerente con quanto individuato nell'attività di analisi dei requisiti;
						\item se possibile, prediligere sempre l'utilizzo di opportuni \glock{design pattern};
						\item evitare l'utilizzo dell'ereditarietà tra classi concrete, prediligendo sempre l'uso di classi astratte e/o interfacce;
						\item perseguire sempre il principio dell'incapsulamento e dell'\textit{information hiding}, limitando il più possibile la visibilità dei dettagli implementativi;
						\item assegnare sempre nomi significativi e parlati a package, classi, metodi e variabili;
						\item evitare la definizione di dipendenze circolari tra classi;
						\item se possibile, definire sempre relazioni tra componenti con il minor grado di dipendenza realizzabile.
					\end{itemize}
					L'attività di progettazione si articola nelle seguenti due parti: 
					\begin{itemize}
						\item \textbf{progettazione architetturale:} definizione delle specifiche, alto livello, dell'architettura e delle componenti del prodotto, delle loro interazioni con le restanti parti del sistema e dei test di integrazione; al termine di questo periodo di progettazione si ottiene la technology baseline del progetto;
						\item \textbf{progettazione di dettaglio:} definizione delle specifiche di dettaglio dell'architettura e delle componenti del prodotto, fino ad arrivare a singole unità, a partire dalla technology baseline; inoltre è sono definiti l'insieme dei diagrammi UML che descrivono l'architettura e le sue componenti, scomposte in unità, e i test necessari per la loro verifica; al termine di questo periodo di progettazione si ottiene la product baseline del progetto.
					\end{itemize}
					
					\subparagraph{Technology baseline}
						La technology baseline include:
						\begin{itemize}
							\item \textbf{\glock{proof of concept}:} primo eseguibile del sistema con funzioni di dimostratore, deve fornire una base di integrazione delle tecnologie necessarie al prodotto finale;
							\item \textbf{tecnologie utilizzate:} descrizione dettagliata delle tecnologie impiegate nello sviluppo del progetto, evidenziandone i pregi e i difetti riscontrati;
							\item \textbf{test di integrazione:} definizione dei test eseguiti per verificare che l'interazione tra le varie componenti del sistema, una volta integrate assieme, funzioni correttamente e in modo conforme ai requisiti;
							\item \textbf{tracciamento delle componenti:} associazione tra requisiti e componenti che li soddisfano.
						\end{itemize}

					\subparagraph{Product baseline}
						La product baseline include:
						\begin{itemize}
							\item \textbf{\glock{design pattern}:} descrizione dei \glock{design pattern} utilizzati nella definizione dell'architettura, per la soluzione progettuale a problemi \textit{ricorrenti} riscontrati; ogni \glock{design pattern} deve essere opportunamente descritto, con una spiegazione del suo significato, ed accompagnato da un diagramma che ne mostri la struttura;
							\item \textbf{\glock{diagrammi UML}:} diagrammi realizzati in linguaggio UML versione 2.0, utilizzati per rendere più chiare le soluzioni progettuali adottate; essi si suddividono in:
							\begin{itemize}
								\item \textbf{diagrammi dei package:} descrivono le dipendenze tra classi raggruppate in diversi package, ossia raggruppamenti di elementi in un'unità di livello più alto;
								\item \textbf{diagrammi delle classi:} rappresentano le classi che compongono il sistema, assieme ai loro attributi e metodi, e le relazioni di dipendenza che sussistono tra loro;			
								\item \textbf{diagrammi di sequenza:} descrivono la collaborazione di un gruppo di oggetti che devono realizzare un determinato comportamento, attraverso una sequenza di azioni e di scelte definite;
								\item \textbf{diagrammi delle attività:} descrivono la logica procedurale di un processo o flusso di operazioni, aiutando a descrivere gli aspetti dinamici dei casi d'uso.
							\end{itemize}
							\item \textbf{test di unità:} definizione dei test eseguiti per verificare che il funzionamento delle varie classi e metodi che implementano il sistema software sia corretto e conforme ai requisiti;
							\item \textbf{tracciamento delle classi:} associazione tra requisiti e classi che li soddisfano.
						\end{itemize}
					
						Segue un'analisi più approfondita dei diagrammi UML e delle caratteristiche che devono avere.

						\textbf{Diagrammi dei package}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi dei package vengono utilizzati per raggruppare gli elementi interni ad un elemento di più alto livello. Ogni package, attraverso il suo nome, identifica un diverso spazio dei nomi, il quale permette di dare un nome qualificato a tutti gli elementi in esso contenuti.
						\newline
						\hangindent=0.6cm Questi diagrammi permettono di rappresentare le dipendenze tra i diversi package che li compongono; questo consente di individuare le dipendenze circolari, in modo da rimuoverle, e di capire quali elementi del sistema dovranno essere i più stabili, verificando quali hanno più dipendenze entranti. Inoltre, tramite i diagrammi dei package è possibile controllare la complessità strutturale del sistema.
						\newline
						\hangindent=0.6cm Rispetto ad altri package esterni, gli elementi interni di un determinato package possono avere visibilità pubblica oppure visibilità privata.
						
						\textbf{Diagrammi delle classi}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi delle classi descrivono i tipi di oggetto presenti nel sistema e le relazioni presenti tra loro.
						\newline
						\hangindent=0.6cm Le classi rappresentate in questi diagrammi presentano le seguenti caratteristiche:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{nome:} nome della classe;
							\item \textbf{attributi (opzionali):} rappresentano lo stato interno della classe; sono identificati dalle seguenti proprietà:
							\begin{itemize}
								\item \textbf{visibilità:} visibilità dell'attributo rispetto ad altre classi, può essere pubblica, protetta o privata;
								\item \textbf{nome:} nome dell'attributo;
								\item \textbf{tipo:} tipo di dato dell'attributo;
								\item \textbf{molteplicità (opzionale):} occorrenze dell'attributo nella classe;
								\item \textbf{default (opzionale):} valore predefinito dell'attributo;
								\item \textbf{proprietà aggiuntive (opzionali);}
							\end{itemize} 
							\item \textbf{operazioni (opzionali):} rappresentano le azioni eseguibili dalla classe; sono identificate dalle seguenti proprietà:
							\begin{itemize}
								\item \textbf{visibilità:} visibilità dell'operazione rispetto ad altre classi, può essere pubblica, protetta o privata;
								\item \textbf{nome:} nome dell'operazione;
								\item \textbf{parametri:} lista dei parametri dell'operazione; ogni parametro è identificato delle seguenti proprietà:
								\begin{itemize}
									\item \textbf{direzione (opzionale):} modalità di accesso al parametro, può essere in lettura, in scrittura o in entrambe;
									\item \textbf{nome:} nome del parametro;
									\item \textbf{tipo:} tipo del parametro;
									\item \textbf{default (opzionale):} valore predefinito del parametro;
								\end{itemize}
								\item \textbf{ritorno:} tipo di ritorno dell'operazione;
								\item \textbf{proprietà aggiuntive (opzionali);}
							\end{itemize}
							\item \textbf{relazioni (opzionali):} rappresentano il grado di dipendenza tra due classi:
							\begin{itemize}
								\item \textbf{dipendenza:} la classe utilizza un oggetto della classe con cui si relaziona;
								\item \textbf{associazione:} la classe crea ed utilizza un oggetto della classe con cui si relaziona;
								\item \textbf{aggregazione:} la classe possiede come attributo un riferimento ad un oggetto condiviso della classe con cui si relazione;
								\item \textbf{composizione:} la classe possiede come attributo un oggetto della classe con cui si relaziona;
								\item \textbf{generalizzazione:} la classe è un istanza che specializza la classe con cui si relazione, ereditandone attributi ed operazioni.
							\end{itemize}
						\end{itemize}

						\hangindent=0.6cm Oltre alle classi, in questi diagrammi possono essere utilizzati i seguenti costrutti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{classe astratte:} rappresenta una classe da cui non è possibile instanziare alcun oggetto, in quanto possiede almeno un'operazione astratta (operazione dichiarata ma non definita); le classi che specializzano una classe astratta, per non essere a loro volta astratte, devono obbligatoriamente prevedere una definizione delle operazioni astratte ereditate;
							\item \textbf{interfaccia:} rappresenta un costrutto simile ad una classe astratta, ma a differenza di quest'ultima non può possedere attributi e tutte le sue operazioni sono obbligatoriamente astratte.
						\end{itemize}
						
						\textbf{Diagrammi di sequenza}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi di sequenza descrivono la realizzazione di un determinato comportamento tramite la collaborazione di più oggetti che si scambiano messaggi, mostrandone il funzionamento della loro interazione nel tempo.
						\newline
						\hangindent=0.6cm I costrutti utilizzati in questi diagrammi sono i seguenti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{partecipante:} rappresenta un oggetto che detiene il flusso di esecuzione e collabora alla realizzazione di un comportamento; un partecipante è composto di due parti:
							\begin{itemize}
								\item \textbf{nome:} nome dell'oggetto partecipante;
								\item \textbf{barra di attivazione:} indicazione della durata del periodo di tempo durante il quale il partecipante è attivo;
							\end{itemize}
							\item \textbf{messaggio:} rappresenta un'operazione di un partecipante che viene chiamata da parte di un altro partecipante e i dati scambiati tra i due; un messaggio può essere di una delle seguenti tipologie:
							\begin{itemize}
								\item \textbf{sincrono:} messaggio di chiamata in cui il partecipante chiamante attende la risposta del partecipante chiamato prima di proseguire la sua esecuzione;
								\item \textbf{asincrono:} messaggio di chiamata in cui il partecipante chiamante non attende la risposta del partecipante chiamato, ma prosegue la sua esecuzione subito dopo la chiamata;
								\item \textbf{ritorno:} messaggio di ritorno riferito ad un precedente messaggio di chiamata;
								\item \textbf{creazione:} messaggio di creazione di un nuovo partecipante da parte del partecipante chiamante;
								\item \textbf{distruzione:} messaggio di distruzione di un partecipante da parte del partecipante chiamante;
							\end{itemize}
							\item \textbf{frame di interazione:} rappresenta un ciclo o una condizione che coinvolge più messaggi e parti delle barre di attivazione di più partecipanti; un frame è caratterizzato dalle seguenti due proprietà:
							\begin{itemize}
								\item \textbf{guardia:} indica la condizione di attivazione del frame, posta in corrispondenza del partecipante coinvolto;
								\item \textbf{etichetta:} indica la tipologia del frame; esistono sette tipi di frame di interazione e sono etichettati nel seguente modo:
								\begin{itemize}
									\item \textbf{alt:} alternativa (tra più frame); è eseguito solo il frame per cui la guardia è verificata;
									\item \textbf{opt:} opzionale; il frame è eseguito solo se la guardia è verificata;
									\item \textbf{par:} parallelo; ogni frame è eseguito in parallelo;
									\item \textbf{loop:} ciclo; il frame può essere eseguito più volte, in base al verificarsi della guardia;
									\item \textbf{region:} regione critica; il frame può essere eseguito da un solo flusso di esecuzione alla volta;
									\item \textbf{neg:} negativo; il frame rappresenta un'interazione non valida;
									\item \textbf{ref:} riferimento; il frame si riferisce ad un'interazione definita in un altro diagramma;
									\item \textbf{sd:} diagramma di sequenza; il frame comprende un intero diagramma di sequenza.
								\end{itemize}
							\end{itemize}
						\end{itemize}

						\hangindent=0.6cm Tramite i diagrammi di sequenza è possibile definire due tipi di controllo dell'elaborazione durante la collaborazione tra i diversi partecipanti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{centralizzato:} un unico partecipante concentra su di se la responsabilità della chiamata dei messaggi verso tutti gli altri partecipanti, governando l'intera elaborazione e quindi diventando un punto critico dell'architettura del sistema;
							\item \textbf{distribuito:} ogni partecipante ha dei compiti ben definiti e la responsabilità della chiamata dei messaggi verso gli altri partecipanti coinvolti.
						\end{itemize}
						
						\textbf{Diagrammi delle attività}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi delle attività descrivono la logica dei processi che compongono l'applicazione software sviluppata. Permettono di rappresentare la parte dinamica dei casi d'uso, mostrando le attività che si possono presentare e in quali sequenze le loro azioni vengono svolte.
						\newline
						\hangindent=0.6cm I costrutti utilizzati in questi diagrammi sono i seguenti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{nodo iniziale:} rappresenta il punto d'inizio dell'esecuzione dell'attività;
							\item \textbf{nodo di fine flusso:} rappresenta un punto di terminazione di un percorso di esecuzione; non causa la terminazione dell'esecuzione dell'attività, in quanto essa può continuare su altri percorsi; 
							\item \textbf{nodo finale:} rappresenta il punto di terminazione dell'esecuzione dell'attività;
							\item \textbf{activity:} rappresenta un'azione all'interno dell'attività, identificata da una breve descrizione;
							\item \textbf{subactivity:} rappresenta una sotto-attività che viene utilizzata per descrivere un'azione che ne comprende altre al suo interno; ogni sotto-attività può essere utilizzata come una singola azione all'interno del diagramma, in modo da non aumentarne troppo la dimensione e la complessità, compromettendone, quindi, la gestione e la comprensione; tuttavia deve essere sempre realizzato un diagramma della sotto-attività che ne illustra l'input, l'output e le azioni presenti al suo interno;
							\item \textbf{pin:} rappresenta un parametro prodotto o consumato da un'azione, con l'indicazione del suo tipo;
							\item \textbf{fork:} rappresenta un punto d'inizio di un elaborazione parallela all'interno dell'attività;
							\item \textbf{join:} rappresenta un punto di sincronizzazione tra più flussi di esecuzione parallela generati in seguito ad un fork;
							\item \textbf{branch:} rappresenta un punto di scelta di uno tra i possibili percorsi di esecuzione disponibili, in base alla condizione di guardia associata a ciascuno di essi;
							\item \textbf{merge:} rappresenta un punto di unione dei diversi percorsi di esecuzione (non paralleli) generati in seguito ad un branch;
							\item \textbf{segnale:} rappresenta un evento esterno, generato in modo non bloccante e catturato in modo bloccante, all'interno dell'attività;
							\item \textbf{timeout:} rappresenta un attesa bloccante all'interno dell'attività, di cui deve essere specificata la durata e l'unità di misura;
							\item \textbf{evento ripetuto:} rappresenta un evento che viene generato ogni intervallo di tempo all'interno dell'attività, di cui deve essere specificata la durata e l'unità di misura;
							\item \textbf{swimlane:} rappresenta una partizione che fornisce una singola responsabilità all'esecuzione delle azioni all'interno di un'attività;
							\item \textbf{regione di espansione:} rappresenta una sequenza di azioni che vengono ripetute sugli elementi di una collezione, presenti in una lista degli argomenti della regione di espansione.
						\end{itemize}

			\paragraph{Codifica}
				\subparagraph{Scopo}
					L'obbiettivo di questa attività è di normare la concretizzazione del prodotto attraverso la programmazione. Quindi gli sviluppatori, durante la fase di implementazione, dovranno attenersi alle norme sotto elencate.
				\subparagraph{Aspettative}
					 L'obbiettivo è lo sviluppo del software richiesto dal proponente utilizzando le norme di programmazione stabilite in modo da:
					 	\begin{itemize}
					 	\item ottenere codice leggibile ed uniforme per i programmatori;
						\item agevolare le fasi di manutenzione, verifica e validazione;
						\item fornire un prodotto conforme alle richieste prefissate dal proponente;
						\item creare un prodotto di qualità.
					 \end{itemize}
				 \subparagraph{Descrizione}
				 	Il codice scritto dovrà rispettare e perseguire quanto stabilito nel documento \dext{Piano di Qualifica v2.0.0} con il fine di fornire una buona qualità del codice.
				 \subparagraph{Stile di codifica}
				 	Per garantire l'uniformità del codice, ciascuno sviluppatore dovrà attenersi alle seguenti norme di programmazione:
					\begin{itemize}
						\item \textbf{indentazione:} i blocchi del codice devono essere indentati, per ciascun livello, con tabulazione la cui larghezza sia impostata a quattro (4) spazi. Ogni programmatore dovrà configurare il proprio editor di testo secondo questa regola (l'indentazione dei commenti non viene considerata);
						\item \textbf{univocità dei nomi:} metodi e variabili devono avere nomi univoci e che ne descrivano il più possibile la funzione dove la prima lettera deve essere sempre minuscola e, nel caso in cui il metodo/variabile sia una concatenazione di più parole, i programmatori devo attenersi al \glock{CamelCase}.
						Per quanto riguarda le classi si applicano le regole esposte in precedenza ad eccezione della lettera iniziale del nome che sarà maiuscola;
						\item \textbf{parentesizzazione:} l'uso delle parentesi è obbligatorio per la disambiguazione, sia logica che non, delle operazioni lineari, es. somma, concatenazione in AND, etc.; inoltre, si impone, nell'uso delle parentesi graffe per la definizione di classi e metodi, di concatenare la parentesi di apertura con la stringa di definizione separandola con uno spazio, per quanto riguarda le parentesi tonde esse non dovranno essere separate da alcun spazio e/o indentazione. La stessa politica viene applicata per costrutti di selezione ed iterazione. Sono ammessi, ove applicabili, operatori ternari, per esempio (\textit{(cond1) ? "stringa1" : var1; }) in \textit{PHP}, con la possibilità di non utilizzare le parentesi graffe. Viene riportato un esempio per chiarificare ulteriormente le prescrizioni sopra citate:
						
						\begin{lstlisting}[language=java,captionpos=b,caption={Esempio di dichiarazione di una classe in Java}]
public class Classe {
	private int var1;
	private int var2;
	private boolean var3;
	
	public void metodo() {
		    while( true ){
				    if( var1 && ( var2 || var3 ))
							  var1 += var2;
						else
						    var2 = var1 + var2;
			}
		}
	
	private int altroMetodo() {
		    if( var3 ){
				  	return var3;
				} else {
					  return var1 + var2;
				}
		}
}
						\end{lstlisting}

						\item \textbf{spazi e capo-riga:} prima di ogni apertura e/o chiusura di parentesi graffa, tonda e quadra ci deve essere uno (1) spazio, fatta eccezione per le parentesi tonde di definizione di metodi. Inoltre, le variabili e simboli dei costrutti lineari dovranno essere separati da uno (1) spazio. Ogni chiusura di parentesi graffa per metodi, classi e condizioni necessita di un capo-riga, fatta eccezione dei costrutti logici \textit{if-else} nei quali la condizione di \textit{else} deve essere separata da uno (1) spazio dalla parentesi graffa di chiusura del costrutto \textit{if}.
					\end{itemize}


		\subsubsection{Metriche}



% NDR ------------------- LE METRICHE VANNO AGGIUNTE NEL RQ ---------------------
%
%		\paragraph{QC-2 Funzionabilità}
%			\subparagraph{Scopo}
				%Durante lo sviluppo si vuole monitorare la capacità del prodotto di soddisfare tutti i requisiti richiesti dall'utente.
%			\subparagraph{Obiettivi}
%				\begin{itemize}
					%\item \textbf{appropriatezza:} viene richiesto che il prodotto metta a disposizione tutte le funzionalità richieste dall'utente;
					%\item \textbf{accuratezza:} il prodotto deve riuscire a produrre risultati che rispettano l'aspettativa ed il grado di precisione richiesti;
					%\item \textbf{interoperabilità:} il prodotto deve essere in grado di interagire ed operare con tutti i sistemi e vincoli specificati;
					%\item \textbf{conformità:} il prodotto deve aderire a standard e regolamenti noti;
					%\item \textbf{sicurezza:} i dati sensibili utilizzati e generati dal prodotto devono essere disponibili esclusivamente agli utenti e/o coloro che risultano autorizzati all'uso di tali dati.
%				\end{itemize}
%			\subparagraph{Introduzione alle Metriche}
%				Per la funzionabilità si é deciso di utilizzare la seguente metrica:
%				\begin{itemize}
%					\item QM-PROD-1 Implementazione (IMP).
%				\end{itemize}
%			\subparagraph{QM-PROD-1 Implementazione (IMP)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica IMP si utilizza per valutare l'avanzamento dello sviluppo delle funzionalità richieste;
%				\item \textbf{unità di misura: }
%					La metrica è espressa in percentuale;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\(
						%IMP = \frac{\# funzionalita implementate}{\# funzionalita proposte}\times100
%					\)
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0\%, allora nessuna funzionalità è stata implementata;
						%\item se il risultato è compreso tra 0\% e 100\%, allora parte delle funzionalità sono state implementate;
						%\item se il risultato è pari a 100\%, allora tutte le funzionalità sono state implementate.
%					\end{itemize}
%			\end{itemize}
%		\paragraph{QC-3 Affidabilità}
%			\subparagraph{Scopo}
				%Durante lo sviluppo si vuole monitorare l'affidabilità e correttezza, così come la sua tolleranza agli errori.
%			\subparagraph{Obiettivi}
%				\begin{itemize}
					%\item \textbf{maturità:} il software deve essere in grado di evitare il verificarsi di errori e/o malfunzionamenti derivanti dalla sua esecuzione;
					%\item \textbf{tolleranza degli errori:} il prodotto é in grado di mantenere un livello minimo di prestazioni predeterminate anche in presenza di malfunzionamenti e/o usi impropri di esso;
					%\item \textbf{recuperabilità:} il software, in seguito ad un errore e/o malfunzionamento, deve essere in grado di ripristinare uno stato di usabilità in un arco di tempo definito e di recuperare eventuali dati persi durante il suddetto lasso di tempo;
					%\item \textbf{aderenza:} descrive la capacitá del prodotto di aderire alle specifiche relative all'affidabilità.
%				\end{itemize}
%			\subparagraph{Introduzione alle Metriche}
%				Per l'affidabilità si é deciso di utilizzare le seguenti metriche:
%				\begin{itemize}
%					\item QM-PROD-2 Densità errori (DE);
%					\item QM-PROD-3 Complessità dei test di classe (CTCLA).
%				\end{itemize}
%			\subparagraph{ QM-PROD-2 Densità errori (DE)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica DE permette di misurare in maniera precisa la tolleranza e correttezza di ogni componente del prodotto, mostrando attraverso una percentuale la sua stabilità;
%				\item \textbf{unità di misura: }
%					La metrica è espressa in percentuale;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\(DE = \frac{\# test passati}{\# test condotti}\times100\)
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0\%, allora il prodotto non è stato testato o ha fallito i test al quale è stato sottoposto;
						%\item se il risultato è compreso tra 0\%, e 100\%, allora parte del prodotto è stato testato e/o il prodotto ha passato parte dei test;
						%\item se il risultato è pari a 100\%, allora tutte le parti sono state testate e il prodotto ha passato tutti i test.
%					\end{itemize}
%			\end{itemize}
%			\subparagraph{QM-PROD-3 Complessità dei test di classe (CTCLA)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica CTCLA trova il suo utilizzo nel monitoraggio dei test che coinvolgono il prodotto e le sue componenti. Essa permette di sapere se ci sono componenti non testate;
%				\item \textbf{unità di misura: }
%					La metrica è espressa tramite un numero intero;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\textit{CTCLA = \# dei test che coinvolgono la classe}
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0, allora il prodotto o componente non è stato incluso in alcun test;
						%\item se il risultato è maggiore di 0, allora il prodotto o componente è stato incluso in almeno un test.
%					\end{itemize}
%			\end{itemize}
%		\paragraph{QC-4 Efficienza}
%			\subparagraph{Scopo}
				%È necessario misurare l'efficienza del prodotto in modo da fornire all'utente un software usabile, piacevole e veloce.
%			\subparagraph{Obiettivi}
%				\begin{itemize}
					%\item \textbf{comportamento nel tempo:} garanzia di tempi di elaborazione accettabili da parte del prodotto;
					%\item \textbf{utilizzo di risorse:} utilizzo non eccessivo delle risorse a disposizione.
%				\end{itemize}
%			\subparagraph{Introduzione alle Metriche}
%				Per l'efficienza si è deciso di utilizzare la seguente metrica:
%				\begin{itemize}
%					\item QM-PROD-4 Risposta media (RM).
%				\end{itemize}
%			\subparagraph{QM-PROD-4 Risposta media (RM)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica RM punta a misurare l'efficienza di elaborazione del prodotto in modo da fornire all'utente un'esperienza piacevole di utilizzo;
%				\item \textbf{unità di misura: }
%					La metrica è espressa millisecondi (\textit{ms});
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\(
%						RM = \frac{\sum_{n=1}^{z} tempo di risposta in ms}{z}
%					\)
%					dove $z$ è il numero di misurazioni effettuate;
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è indica il tempo di risposta medio del prodotto.
%					\end{itemize}
%			\end{itemize}
%		\paragraph{QC-5 Usabilità}
%			\subparagraph{Scopo}
			%Si vuole misurare l'usabilità del prodotto in modo da fornire all'utente un'esperienza piacevole durante il suo utilizzo, nonché fornire un prodotto facile da apprendere ed utilizzare.
%			\subparagraph{Obiettivi}
%				\begin{itemize}
					%\item \textbf{comprensibilità:} determina la facilità di utilizzo e di comprensione del prodotto e delle sue funzionalità da parte dell'utente;
					%\item \textbf{apprendibilità:} definisce il livello di impegno richiesto, da parte dell'utilizzatore, per imparare ad usare il prodotto;
					%\item \textbf{operabilità:} stabilisce il grado con cui il software riesce a mettere il suo utilizzatore in condizione di sfruttare il prodotto per i suoi fini;
					%\item \textbf{attrattiva:} la proprietà del software di produrre un'esperienza d'uso gradevole per l'utente.
%				\end{itemize}
%			\subparagraph{Introduzione alle Metriche}
%				Per la funzionabilità si é deciso di utilizzare le seguenti metriche:
%				\begin{itemize}
%					\item QM-PROD-5 Profondità dell'albero delle azioni (PAA);
%					\item QM-PROD-6 Profondità dell'albero delle pagine (PAP).
%				\end{itemize}
%			\subparagraph{QM-PROD-5 Profondità dell'albero delle azioni (PAA)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica PAA permette di misurare l'operabilità e la comprensibilità del prodotto da parte dell'utente. Essa misura il numero di azioni effettuate dall'utente prima di poter arrivare al suo obbiettivo;
%				\item \textbf{unità di misura: }
%					La metrica è espressa tramite un numero intero;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\textit{PAA = \# delle azioni}
%					dove ogni click corrisponde ad un'azione;
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari 0 allora l'obbiettivo non è raggiungibile e/o l'utente non ne ha accesso;
						%\item se il risultato è maggiore di 0 allora l'obbiettivo è raggiungibile in un numero finito di azioni.
%					\end{itemize}
%			\end{itemize}
%			\subparagraph{QM-PROD-6 Profondità dell'albero delle pagine (PAP)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica PAP permette di misurare l'apprendibilità, l'operabilità e l'attrattiva del prodotto dal punto di vista del cliente. Essa misura il numero di pagine visitate dall'utente prima di poter arrivare al suo obbiettivo;
%				\item \textbf{unità di misura: }
%					La metrica è espressa tramite un numero intero;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\textit{PAP = \# delle pagine visitate dall'utente}
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0 allora la pagina obbiettivo non esiste o l'utente non ne ha accesso;
						%\item se il risultato è maggiore di 0 allora la pagina obbiettivo è raggiungibile in un numero finito di passaggi.
%					\end{itemize}
%			\end{itemize}
%		\paragraph{QC-6 Manutenibilità}
%			\subparagraph{Scopo}
				%La manutenibilità viene monitorata in modo da fornire un prodotto modificabile ed estendibile, in modo da poter estendere facilmente sia la vita del prodotto che le sue funzionalità.
%				\begin{itemize}
					%\item \textbf{analizzabilità:} determina la facilità con cui é possibile analizzare e localizzare un errore all'interno del codice;
					%\item \textbf{modificabilità:} definisce la capacitá del prodotto di apportare una modifica o una estensione;
					%\item \textbf{stabilità:} il software deve essere un grado di essere usato anche in caso le modifiche apportate siano errate;
					%\item \textbf{testabilità:} determina la capacità del software di essere testato facilmente per fornire una validazione delle modifica apportate.
%				\end{itemize}
%			\subparagraph{Introduzione alle Metriche}
				%Per la funzionabilità si é deciso di utilizzare le seguenti metricche:
%				\begin{itemize}
%					\item QM-PROD-QM-PROD-7 Complessità del codice (CCOD);
%					\item QM-PROD-8 Complessità della classe (CCLA);
%					\item QM-PROD-9 Complessità del metodo (CMET).
%				\end{itemize}
%			\subparagraph{QM-PROD-7 Complessità del codice (CCOD)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica CCOD permette di misurare la chiarezza dei commenti rispetto la lunghezza del codice scritto;
%				\item \textbf{unità di misura: }
%					La metrica è espressa tramite un numero reale;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%				 \(
%				 		CCOD = \frac{\# linee commento}{\# linee codice}
%				 \)
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0, allora il codice non è stato commentato;
						%\item se il risultato è maggiore di 0, allora il codice ha almeno una riga di commento.
%					\end{itemize}
%			\end{itemize}
%			\subparagraph{QM-PROD-8 Complessità della classe (CCLA)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica CCLA misure il numero di metodi presenti in ogni classe e permette di valutare la complessità generale della stessa;
%				\item \textbf{unità di misura: }
%					La metrica è espressa tramite un numero intero;
%				\item \textbf{formula: }
%					La formula della metrica è la seguente:
%					\textit{CCLA = \# numero metodi}
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0, allora la classe non esiste e/o non ha metodi che le appartengono;
						%\item se il risultato è maggiore di 0, allora la classe esiste ed ha un numero finito di metodi.
%					\end{itemize}
%			\end{itemize}
%			\subparagraph{QM-PROD-9 Complessità del metodo (CMET)}
%			\begin{itemize}
%      			\item \textbf{descrizione: }
					%La metrica CMET permette di valutare la complessità di ogni metodo rispetto la sua modificabilità, ossia permette di capire se un metodo è una \glock{maschera} o esegue azioni rilevanti;
%				\item \textbf{unità di misura: }
%					La metrica è espressa tramite un numero reale;
%				\item \textbf{formula :}
%					La formula della metrica è la seguente:
%					\(
						%CMET = \frac{\# linee codice}{\# chiamate interne ad altri metodi+1}
%					\)
%				\item \textbf{risultato: }
%					Il risultato della formula ha i seguenti significati:
%					\begin{itemize}
						%\item se il risultato è pari a 0, allora il metodo non esiste e/o non è stato implementato;
						%\item se il risultato è maggiore di 0, allora il metodo è stato implementato ed potrebbe effettuare chiamate interne;
%					\end{itemize}
%					Più è alto il risultato meno è la complessità del metodo.
%			\end{itemize}


		\subsubsection{Strumenti}
			Di seguito sono elencati gli strumenti che verranno utilizzati nel processo di sviluppo.
							
				\paragraph{IntelliJ Idea - Ultimate Edition}
					IntelliJ Idea è un IDE sviluppato da \textit{JetBrains} che viene utilizzato per lo sviluppo di applicativi \textit{Java} e permette di agevolare ampiamente uno sviluppatore, grazie agli strumenti aggiuntivi che possono essere facilmente configurati. Include anche la possibilità di usare un debugger, eseguire refactoring del codice, configurare un sistema di versionamento e integrarsi con i framework più utilizzati per \textit{Java} come \glock{Spring}. Il software è a pagamento, ma gratuito per gli studenti universitari. 

					\begin{itemize}
						\item IntelliJ Idea genera una cartella \verb!.idea! che non deve essere aggiunta al sistema di versionamento;
						\item analogamente, anche le cartelle di output, \verb!out/! e \verb!target/!, non devono essere versionate.
					\end{itemize}

				\paragraph{PHPStorm}
					PHPStorm è un IDE sviluppato da \textit{JetBrains}, molto simile a IntelliJ Idea, che viene usato per lo sviluppo della webapp che fa uso di HTML, PHP e Javascript. Si integra facilmente con \glock{Laravel} e altri framework molto usati e in particolare permette di configurare tutto in modo automatico, agevolando lo sviluppatore. PHPStorm è gratuito per gli studenti universitari e può essere riscattato allo stesso modo IntelliJ Idea dal sito ufficiale. 

					\begin{itemize}
						\item PHPStorm genera una cartella \verb!.idea! che non deve essere aggiunta al sistema di versionamento;
						\item analogamente, anche le cartelle di output, \verb!out/! e \verb!target/!, non devono essere versionate.
					\end{itemize}

				\paragraph{Visual Studio Code} 
					Visual Studio Code è un editor di codice sorgente sviluppato da \textit{Microsoft} per Windows, Linux e MacOS. Include una serie di estensioni che possono essere utilizzate al fine di arricchire l'editor in base alle necessità. Nell'ambito del progetto, Visual Studio Code può essere utilizzato per lo sviluppo del codice sorgente e di board come \glock{Arduino Uno} e \glock{ESP8266}, con le quali è possibile simulare fisicamente un dispositivo industriale.
				
				\paragraph{Maven}
					Maven è uno strumento sviluppato da \textit{Apache} e utilizzato per la gestione del progetto. Permette di configurare tutte le dipendenze e tutti i plugin che servono allo sviluppo di una applicazione \textit{Java}. Integrato con \textit{IntelliJ Idea}, permette di configurare automaticamente la repository di progetto, scaricando e cancellando autonomamente le dipendenze necessarie in base a quanto riportato nel \verb!pom.xml!. Questo file si trova nella cartella principale del \textit{git submodule} in cui viene sviluppata l'applicazione \textit{Java} e può essere modificato in base alle necessità. Di seguito si mostra un esempio di \verb!pom.xml!


					\begin{lstlisting}[language=xml,captionpos=b,caption={Esempio di implementazione di un file pom.xml}]
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>groupId</groupId>
    <artifactId>swe-gateway</artifactId>
    <version>1.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>org.apache.kafka</groupId>
            <artifactId>kafka_2.13</artifactId>
            <version>2.4.0</version>
        </dependency>
        <dependency>
            <groupId>org.jetbrains</groupId>
            <artifactId>annotations-java5</artifactId>
            <version>RELEASE</version>
            <scope>compile</scope>
        </dependency>

        <!-- ... -->

    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <release>11</release>
                </configuration>
            </plugin>
        </plugins>
    </build>

    
</project>\end{lstlisting}


				\paragraph{Portainer}
					Portainer è un applicativo web che si utilizza per la gestione dei \glock{container} che vengono istanziati in una macchina locale o remota che fa uso di \glock{Docker}. Lo stesso applicativo risulta essere una istanza di un \glock{container}, che può essere installato in qualunque momento. Dal pannello di gestione è possibile:
					\begin{itemize}
						\item aggiungere, modificare e rimuovere \glock{container};
						\item avviare, fermare e riavviare \glock{container};
						\item visualizzare i logs di un singolo \glock{container};
						\item operare dentro il \glock{container} a riga di comando;
						\item modificare la configurazione di rete e di avvio del \glock{container};
						\item aggiungere ed eseguire il processo di build delle \glock{immagini} di \glock{Docker}. 
					\end{itemize}

				\paragraph{Kafka Manager}
					Kafka manager è una webapp che permette di monitorare e operare sugli stream di \glock{Kafka}. La webapp è facilmente accessibile tramite browser e permette di gestire nel modo più completo ciò che avviene sulle singole istanze di \glock{topic}, verificando effettivamente il funzionamento dell'infrastruttura. Inoltre, è possibile:
					\begin{itemize}
					 	\item creare manualmente nuovi topic;
					 	\item cancellare topic esistenti;
					 	\item aggiornare dei parametri di configurazione di un particolare topic;
					 	\item controllare il flusso di produzione e consumazione dei messaggi.
					 \end{itemize} 

				\paragraph{Firefox} 
					Browser web sviluppato dalla \textit{Mozilla Foundations} che viene utilizzato per visualizzare la webapp e accedere alle interfacce online di \glock{Docker}. Il browser è gratuito e scaricabile dal sito ufficiale per qualunque sistema operativo.

				\paragraph{Chrome} 
					Chrome è un browser web sviluppato da \textit{Google} che viene utilizzato in alternativa a \textit{Firefox}, per la visualizzazione della webapp e per accedere agli strumenti online. Viene utilizzato sia a livello desktop, che a livello mobile, specialmente negli smartphone \textit{android}.

				\paragraph{Safari} 
					Safari è un browser web sviluppato da \textit{Apple} che viene utilizzato per accedere e testare la webapp su \textit{MacOs}. Esiste una versione mobile del browser che viene utilizzata nativamente negli smartphone \textit{Apple}.