\subsection{Sviluppo}
		\subsubsection{Scopo}
			Il processo di sviluppo definisce i compiti e le attività da intraprendere per ottenere il prodotto finale richiesto dal proponente.
		\subsubsection{Aspettative}
			Per una corretta implementazione di questo processo è necessario fissare:
				\begin{itemize}
					\item obiettivi di sviluppo;
					\item vincoli tecnologici e di design.
				\end{itemize}
			Il prodotto finale deve rispettare i requisiti e le aspettative del proponente, superando i test definiti dalle norme di qualità.
		\subsubsection{Descrizione}
			Il processo di sviluppo, secondo lo standard ISO/IEC 12207:1995, si articola nelle seguenti attività:
				\begin{itemize}
					\item analisi dei requisiti;
					\item progettazione;
					\item codifica.
				\end{itemize}

		\subsubsection{Attività}
			Di seguito verranno analizzate dettagliatamente le attività menzionate nella sezione precedente.
			\paragraph{Analisi dei requisiti}
				\subparagraph{Scopo}
					Gli analisti si occupano di stilare il documento di analisi dei requisiti, il cui scopo è definire ed elencare tutti i requisiti del capitolato. Il documento finale conterrà:
					\begin{itemize}
						\item descrizione generale del prodotto;
						\item argomentazioni precise ed affidabili per i progettisti;
						\item casi d'uso rappresentati tramite diagrammi UML;
						\item funzionalità e requisiti concordi con le richieste del cliente;
						\item tracciamento dei requisiti individuati.
					\end{itemize}
				\subparagraph{Aspettative}
					Creazione del documento formale contente tutti i requisiti richiesti dal proponente per la realizzazione del capitolato.
				\subparagraph{Classificazione dei Requisiti}
					Al fine di facilitarne la consultazione e comprensione, i requisiti saranno classificati ed identificati univocamente secondo il seguente schema identificativo:
					\begin{center}
						\textbf{R[Priorità]-[Tipologia]-[Identificativo]}
					\end{center}
					Dove:
					\begin{itemize}
						\item \textbf{R:} indica che si tratta di un requisito;
						\item \textbf{Priorità:} assume, a seconda del grado di priorità, i valori:
						\begin{itemize}
							\item \textbf{A:} obbligatorio, cioè strettamente necessario;
							\item \textbf{B:} desiderabile, cioè non strettamente necessario;
							\item \textbf{C:} opzionale, cioè contrattabile in corso d'opera;
						\end{itemize}
						\item \textbf{Tipologia:} a seconda del tipo di requisito, assume i valori:
						\begin{itemize}
							\item \textbf{F:} funzionale;
							\item \textbf{P:} prestazionale;
							\item \textbf{Q:} qualitativo;
							\item \textbf{V:} vincolo;
						\end{itemize}
						\item \textbf{Identificativo:} numero progressivo per contraddistinguere il requisito, in forma gerarchica padre-figlio strutturato come segue:
						\begin{center}
							\textbf{[codicePadre].[codiceFiglio]}
						\end{center}
					\end{itemize}
				\subparagraph{Classificazione dei casi d'uso}
					Gli analisti, dopo la stesura dei requisiti, hanno anche il compito di identificare ed elencare i casi d'uso. Ognuno di essi è identificato, in maniera univoca, secondo il seguente schema identificativo:
					\begin{center}
						\textbf{UC[codiceCaso].[codiceSottoCaso].[codiceSottoSottoCaso]}
					\end{center}
					Ogni caso d'uso oltre al codice di identificazione deve contenere, integralmente o parzialmente, i seguenti campi:
					\begin{itemize}
						\item \textbf{diagrammi UML:} diagrammi realizzati usando la versione 2.0 del linguaggio;
						\item \textbf{attori primari:} attori principali del caso d'uso;
						\item \textbf{attori secondari:} attori secondari del caso d'uso;
						\item \textbf{descrizione:} breve descrizione del caso d'uso;
						\item \textbf{attori secondari:} attori secondari del caso d'uso;
						\item \textbf{estensioni:} eventuali estensioni coinvolte;
						\item \textbf{inclusioni:} eventuali inclusioni coinvolte;
						\item \textbf{precondizione:} condizioni che devono essere soddisfatte perché si verifichino gli eventi del caso d'uso;
						\item \textbf{post-condizione:} condizioni che devono essere soddisfatte dopo il verificarsi degli eventi del caso d'uso;
						\item \textbf{scenario principale:} flusso degli eventi, in forma di elenco numerato, con eventuale riferimento ad ulteriori casi d'uso.
					\end{itemize}

			\paragraph {Progettazione}
				\subparagraph{Scopo}
					L'attività di progettazione precede quella di codifica ed avviene successivamente all'analisi dei requisiti.
					\newline
					In questa attività i progettisti hanno il compito di definire una soluzione del problema che sia soddisfacente per gli \glock{stakeholder}.
					\newline
					Lo scopo della progettazione è definire l'architettura logica del prodotto da sviluppare e deve permettere di:
					\begin{itemize}
						\item garantire l'efficacia del prodotto, soddisfacendo tutti i requisiti individuati nell'attività di analisi, attraverso un sistema di qualità che persegua il principio di correttezza per costruzione;
						\item garantire l'efficienza nella realizzazione del prodotto, impiegando parti riusabili con specifiche chiare, organizzate in modo da facilitarne la manutenzione, e realizzabili ottimizzando l'utilizzo delle risorse disponibili;
						\item gestire la complessità del sistema, suddividendolo fino ad ottenere delle parti di complessità trattabile, che possano essere fornite in ingresso all'attività di codifica come singoli compiti individuali che siano, quindi, fattibili, rapidi e verificabili.
					\end{itemize}

				\subparagraph{Aspettative}
					Le aspettative della progettazione è la definizione l'architettura logica del prodotto, la quale dovrà godere delle seguenti qualità:
					\begin{itemize}
						\item \textbf{sufficienza:} capace di soddisfare tutti i requisiti;
						\item \textbf{comprensibilità:} capibile da tutti gli stakeholder;
						\item \textbf{modularità:} suddivisibile in parti chiare e ben distinte, riducendo la dipendenza tra le parti stesse, per ridurre i cambiamenti esterni causati da modifiche interne ad una singola parte;
						\item \textbf{robustezza:} capace di sopportare ingressi diversi da parte dell'utente e dell'ambiente;
						\item \textbf{flessibilità:} modificabile a costo contenuto al variare dei requisiti;
						\item \textbf{efficienza nella gestione delle risorse;}
						\item \textbf{affidabilità:} se utilizzata correttamente, garantisce di ottenere il risultato desiderato;
						\item \textbf{disponibilità:} richiede un tempo di indisponibilità limitato o nullo per effettuare la manutenzione;
						\item \textbf{sicurezza:} non presenta malfunzionamenti gravi nè vulnerabilità alle intrusioni;
						\item \textbf{semplicità:} composta di parti contenenti solamente il necessario e nulla di superfluo;
						\item \textbf{incapsulazione:} composta di parti la cui struttura interna non è visibile da fuori, in modo da ridurre le dipendenze indotte sull'esterno e quindi facilitare la manutenzione;
						\item \textbf{coesione:} composta da parti raggruppate per obiettivi comuni, in modo da ridurre l'interdipendenza tra le componenti e quindi aumentare la manutenibilità e la comprensibilità;
						\item \textbf{basso accoppiamento:} composta da parti distinte con dipendenza bassa o nulla le une dalle altre.
					\end{itemize}

				\subparagraph{Descrizione}
					Per perseguire la qualità nella progettazione dell'architettura è necessario seguire le seguenti regole:
					\begin{itemize}
						\item ogni attività svolta deve essere coerente con quanto individuato nell'attività di analisi dei requisiti;
						\item se possibile, prediligere sempre l'utilizzo di opportuni \glock{design pattern};
						\item evitare l'utilizzo dell'ereditarietà tra classi concrete, prediligendo sempre l'uso di classi astratte e/o interfacce;
						\item perseguire sempre il principio dell'incapsulamento e dell'\textit{information hiding}, limitando il più possibile la visibilità dei dettagli implementativi;
						\item assegnare sempre nomi significativi e parlanti a package, classi, metodi e variabili;
						\item evitare la definizione di dipendenze circolari tra classi;
						\item se possibile, definire sempre relazioni tra componenti con il minor grado di dipendenza realizzabile.
					\end{itemize}
					L'attività di progettazione si articola nelle seguenti due parti:
					\begin{itemize}
						\item \textbf{progettazione architetturale:} definizione delle specifiche, ad alto livello, dell'architettura e delle componenti del prodotto, delle loro interazioni con le restanti parti del sistema e dei test di integrazione; al termine di questo periodo di progettazione si ottiene la technology baseline del progetto;
						\item \textbf{progettazione di dettaglio:} definizione delle specifiche di dettaglio dell'architettura e delle componenti del prodotto, fino ad arrivare a singole unità, a partire dalla technology baseline; inoltre sono definiti l'insieme dei diagrammi UML che descrivono l'architettura e le sue componenti, scomposte in unità, e i test necessari per la loro verifica; al termine di questo periodo di progettazione si ottiene la product baseline del progetto.
					\end{itemize}

					\subparagraph{Technology baseline}
						La technology baseline deve includere:
						\begin{itemize}
							\item \textbf{\glock{proof of concept}:} primo eseguibile del sistema con funzione dimostrativa, deve fornire una base di integrazione delle tecnologie necessarie al prodotto finale;
							\item \textbf{tecnologie utilizzate:} descrizione dettagliata delle tecnologie impiegate nello sviluppo del progetto, con particolare enfasi sui pregi e i difetti riscontrati;
							\item \textbf{test di integrazione:} definizione dei test eseguiti per verificare che le varie componenti del sistema, una volta integrate insieme, interagiscano in modo corretto e in conformità con quanto richiesto dai requisiti;
							\item \textbf{tracciamento delle componenti:} associazione tra requisiti e componenti che li soddisfano.
						\end{itemize}

					\subparagraph{Product baseline}
						La product baseline deve includere:
						\begin{itemize}
							\item \textbf{\glock{design pattern}:} descrizione dei design pattern utilizzati nella definizione dell'architettura, per la soluzione progettuale a problemi \textit{ricorrenti} riscontrati; ogni design pattern deve essere opportunamente descritto, con una spiegazione del suo significato, ed accompagnato da un diagramma che ne mostri la struttura;
							\item \textbf{\glock{diagrammi UML}:} diagrammi realizzati in linguaggio UML versione 2.0, utilizzati per rendere più chiare le soluzioni progettuali adottate; essi si suddividono in:
							\begin{itemize}
								\item \textbf{diagrammi dei package:} descrivono le dipendenze tra classi raggruppate in diversi package, ossia raggruppamenti di elementi in un'unità di livello più alto;
								\item \textbf{diagrammi delle classi:} rappresentano le classi che compongono il sistema, assieme ai loro attributi e metodi, e le relazioni di dipendenza che sussistono tra loro;
								\item \textbf{diagrammi di sequenza:} descrivono la collaborazione di un gruppo di oggetti che devono realizzare un determinato comportamento, attraverso una sequenza di azioni e di scelte definite;
								\item \textbf{diagrammi delle attività:} descrivono la logica procedurale di un processo o flusso di operazioni, aiutando a descrivere gli aspetti dinamici dei casi d'uso.
							\end{itemize}
							\item \textbf{test di unità:} definizione dei test eseguiti per verificare che il funzionamento delle varie classi e metodi che implementano il sistema software sia corretto e conforme ai requisiti;
							\item \textbf{tracciamento delle classi:} associazione tra requisiti e classi che li soddisfano.
						\end{itemize}

						Segue un'analisi più approfondita dei diagrammi UML e delle caratteristiche che devono avere.

						\textbf{Diagrammi dei package}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi dei package vengono utilizzati per raggruppare gli elementi interni ad un elemento di più alto livello. Ogni package identifica un diverso spazio dei nomi, il quale permette di dare un nome qualificato a tutti gli elementi in esso contenuti.
						\newline
						\hangindent=0.6cm Questi diagrammi permettono di rappresentare le dipendenze tra i diversi package che li compongono; ciò consente di individuare le dipendenze circolari, in modo da rimuoverle, e di capire quali elementi del sistema dovranno essere i più stabili, verificando quali hanno più dipendenze entranti. Inoltre, tramite i diagrammi dei package è possibile controllare la complessità strutturale del sistema.
						\newline
						\hangindent=0.6cm Rispetto ad altri package esterni, gli elementi interni di un determinato package possono avere visibilità pubblica oppure privata.

						\textbf{Diagrammi delle classi}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi delle classi descrivono i tipi di oggetto presenti nel sistema e le relazioni presenti tra essi.
						\newline
						\hangindent=0.6cm Le classi rappresentate in questi diagrammi presentano le seguenti caratteristiche:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{nome:} nome della classe;
							\item \textbf{attributi (opzionali):} rappresentano lo stato interno della classe; sono identificati dalle seguenti proprietà:
							\begin{itemize}
								\item \textbf{visibilità:} visibilità dell'attributo rispetto ad altre classi, può essere pubblica, protetta o privata;
								\item \textbf{nome:} nome dell'attributo;
								\item \textbf{tipo:} tipo di dato dell'attributo;
								\item \textbf{molteplicità (opzionale):} occorrenze dell'attributo nella classe;
								\item \textbf{default (opzionale):} valore predefinito dell'attributo;
								\item \textbf{proprietà aggiuntive (opzionali);}
							\end{itemize}
							\item \textbf{operazioni (opzionali):} rappresentano le azioni eseguibili dalla classe; sono identificate dalle seguenti proprietà:
							\begin{itemize}
								\item \textbf{visibilità:} visibilità dell'operazione rispetto ad altre classi, può essere pubblica, protetta o privata;
								\item \textbf{nome:} nome dell'operazione;
								\item \textbf{parametri:} lista dei parametri dell'operazione; ogni parametro è identificato delle seguenti proprietà:
								\begin{itemize}
									\item \textbf{direzione (opzionale):} modalità di accesso al parametro, può essere in lettura, in scrittura o in entrambe;
									\item \textbf{nome:} nome del parametro;
									\item \textbf{tipo:} tipo del parametro;
									\item \textbf{default (opzionale):} valore predefinito del parametro;
								\end{itemize}
								\item \textbf{ritorno:} tipo di ritorno dell'operazione;
								\item \textbf{proprietà aggiuntive (opzionali);}
							\end{itemize}
							\item \textbf{relazioni (opzionali):} rappresentano il grado di dipendenza tra due classi:
							\begin{itemize}
								\item \textbf{dipendenza:} la classe utilizza un oggetto della classe con cui si relaziona;
								\item \textbf{associazione:} la classe crea ed utilizza un oggetto della classe con cui si relaziona;
								\item \textbf{aggregazione:} la classe possiede come attributo un riferimento ad un oggetto condiviso della classe con cui si relazione;
								\item \textbf{composizione:} la classe possiede come attributo un oggetto della classe con cui si relaziona;
								\item \textbf{generalizzazione:} la classe è un istanza che specializza la classe con cui si relazione, ereditandone attributi ed operazioni.
							\end{itemize}
						\end{itemize}

						\hangindent=0.6cm Oltre alle classi, in questi diagrammi possono essere utilizzati i seguenti costrutti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{classe astratte:} rappresenta una classe di cui non è possibile instanziare alcun oggetto, in quanto possiede almeno un'operazione astratta (operazione dichiarata ma non definita); le classi che specializzano una classe astratta, per non essere a loro volta astratte, devono obbligatoriamente prevedere una definizione delle operazioni astratte ereditate;
							\item \textbf{interfaccia:} rappresenta un costrutto simile ad una classe astratta, ma a differenza di quest'ultima non può possedere attributi e tutte le sue operazioni sono obbligatoriamente astratte.
						\end{itemize}

						\textbf{Diagrammi di sequenza}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi di sequenza descrivono la realizzazione di un determinato comportamento tramite la collaborazione di più oggetti che si scambiano messaggi, mostrandone il funzionamento della loro interazione nel tempo.
						\newline
						\hangindent=0.6cm I costrutti utilizzati in questi diagrammi sono i seguenti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{partecipante:} rappresenta un oggetto che detiene il flusso di esecuzione e collabora alla realizzazione di un comportamento; un partecipante è composto di due parti:
							\begin{itemize}
								\item \textbf{nome:} nome dell'oggetto partecipante;
								\item \textbf{barra di attivazione:} indicazione della durata del periodo di tempo durante il quale il partecipante è attivo;
							\end{itemize}
							\item \textbf{messaggio:} rappresenta un'operazione di un partecipante che viene chiamata da parte di un altro partecipante e i dati scambiati tra i due; un messaggio può essere di una delle seguenti tipologie:
							\begin{itemize}
								\item \textbf{sincrono:} messaggio di chiamata in cui il partecipante chiamante attende la risposta del partecipante chiamato prima di proseguire la sua esecuzione;
								\item \textbf{asincrono:} messaggio di chiamata in cui il partecipante chiamante non attende la risposta del partecipante chiamato, ma prosegue la sua esecuzione subito dopo la chiamata;
								\item \textbf{ritorno:} messaggio di ritorno riferito ad un precedente messaggio di chiamata;
								\item \textbf{creazione:} messaggio di creazione di un nuovo partecipante da parte del partecipante chiamante;
								\item \textbf{distruzione:} messaggio di distruzione di un partecipante da parte del partecipante chiamante;
							\end{itemize}
							\item \textbf{frame di interazione:} rappresenta un ciclo o una condizione che coinvolge più messaggi e parti delle barre di attivazione di più partecipanti; un frame è caratterizzato dalle seguenti due proprietà:
							\begin{itemize}
								\item \textbf{guardia:} indica la condizione di attivazione del frame, posta in corrispondenza del partecipante coinvolto;
								\item \textbf{etichetta:} indica la tipologia del frame; esistono sette tipi di frame di interazione e sono etichettati nel seguente modo:
								\begin{itemize}
									\item \textbf{alt:} alternativa (tra più frame), è eseguito solo il frame per cui la guardia è verificata;
									\item \textbf{opt:} opzionale, il frame è eseguito solo se la guardia è verificata;
									\item \textbf{par:} parallelo, ogni frame è eseguito in parallelo;
									\item \textbf{loop:} ciclo, il frame può essere eseguito più volte, in base al verificarsi della guardia;
									\item \textbf{region:} regione critica, il frame può essere eseguito da un solo flusso di esecuzione alla volta;
									\item \textbf{neg:} negativo, il frame rappresenta un'interazione non valida;
									\item \textbf{ref:} riferimento, il frame si riferisce ad un'interazione definita in un altro diagramma;
									\item \textbf{sd:} diagramma di sequenza, il frame comprende un intero diagramma di sequenza.
								\end{itemize}
							\end{itemize}
						\end{itemize}

						\hangindent=0.6cm Tramite i diagrammi di sequenza è possibile definire due tipi di controllo dell'elaborazione durante la collaborazione tra i diversi partecipanti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{centralizzato:} un unico partecipante concentra su di sè la responsabilità della chiamata dei messaggi verso tutti gli altri partecipanti, governando l'intera elaborazione; diventa quindi un punto critico dell'architettura del sistema;
							\item \textbf{distribuito:} ogni partecipante ha dei compiti ben definiti e la responsabilità della chiamata dei messaggi verso gli altri partecipanti coinvolti.
						\end{itemize}

						\textbf{Diagrammi delle attività}
						\newline
						\newline
						\hangindent=0.6cm I diagrammi delle attività descrivono la logica dei processi che compongono l'applicazione software sviluppata. Permettono di rappresentare la parte dinamica dei casi d'uso, mostrando le attività che si possono presentare e le sequenze in cui le loro azioni vengono svolte.
						\newline
						\hangindent=0.6cm I costrutti utilizzati in questi diagrammi sono i seguenti:
						\begin{itemize}[leftmargin=1.5cm]
							\item \textbf{nodo iniziale:} rappresenta il punto d'inizio dell'esecuzione dell'attività;
							\item \textbf{nodo di fine flusso:} rappresenta un punto di terminazione di un percorso di esecuzione; non causa la terminazione dell'esecuzione dell'attività, in quanto essa può continuare su altri percorsi;
							\item \textbf{nodo finale:} rappresenta il punto di terminazione dell'esecuzione dell'attività;
							\item \textbf{activity:} rappresenta un'azione all'interno dell'attività, identificata da una breve descrizione;
							\item \textbf{subactivity:} rappresenta una sotto-attività utilizzata per descrivere un'azione che ne comprende altre al suo interno; ogni sotto-attività può essere utilizzata come una singola azione all'interno del diagramma, in modo da non aumentarne troppo la dimensione e la complessità, e non comprometterne, quindi, la gestione e la comprensione; tuttavia deve essere sempre realizzato un diagramma della sotto-attività che ne illustri l'input, l'output e le azioni contenute;
							\item \textbf{pin:} rappresenta un parametro prodotto o consumato da un'azione, con l'indicazione del suo tipo;
							\item \textbf{fork:} rappresenta un punto d'inizio di un elaborazione parallela all'interno dell'attività;
							\item \textbf{join:} rappresenta un punto di sincronizzazione tra più flussi di esecuzione parallela generati in seguito ad un fork;
							\item \textbf{branch:} rappresenta il punto di scelta di uno tra i possibili percorsi di esecuzione disponibili, in base alla condizione di guardia associata a ciascuno di essi;
							\item \textbf{merge:} rappresenta un punto di unione dei diversi percorsi di esecuzione (non paralleli) generati in seguito ad un branch;
							\item \textbf{segnale:} rappresenta un evento esterno, generato in modo non bloccante e catturato in modo bloccante, all'interno dell'attività;
							\item \textbf{timeout:} rappresenta un attesa bloccante all'interno dell'attività, di cui deve essere specificata la durata e l'unità di misura;
							\item \textbf{evento ripetuto:} rappresenta un evento che viene generato ad intervalli regolari all'interno dell'attività, di cui deve essere specificata la durata e l'unità di misura;
							\item \textbf{swimlane:} rappresenta una partizione che fornisce una singola responsabilità all'esecuzione delle azioni all'interno di un'attività;
							\item \textbf{regione di espansione:} rappresenta una sequenza di azioni che vengono ripetute sugli elementi di una collezione, presenti in una lista degli argomenti della regione di espansione.
						\end{itemize}

			\paragraph{Codifica}
				\subparagraph{Scopo}
					Lo scopo di questa attività è di normare la concretizzazione del prodotto attraverso la programmazione. Gli sviluppatori, durante la fase di implementazione, dovranno attenersi alle norme sotto elencate.
				\subparagraph{Aspettative}
					 L'obiettivo è lo sviluppo del software richiesto dal proponente, utilizzando le norme di programmazione stabilite, in modo da:
					 	\begin{itemize}
					 	\item ottenere codice leggibile ed uniforme per i programmatori;
						\item agevolare le fasi di manutenzione, verifica e validazione;
						\item fornire un prodotto conforme alle richieste prefissate dal proponente;
						\item realizzare un prodotto di qualità.
					 \end{itemize}
				 \subparagraph{Descrizione}
				 	Il codice scritto dovrà rispettare le norme stabilite in questo documento, con il fine di perseguire una buona livello di qualità, conforme alle metriche stabilite.
				 \subparagraph{Stile di codifica}
				 	Per garantire l'uniformità del codice, in base al linguaggio utilizzato, ciascuno sviluppatore dovrà attenersi a quanto segue:
					\begin{itemize}
						\item \textbf{Java:} si è deciso di seguire le linee guida fornite da \glock{Google} per il linguaggio, in particolare:
							\begin{itemize}
								\item \textbf{parentesizzazione:} le parentesi graffe verranno utilizzate sempre, anche se il corpo del blocco è vuoto o con una sola istruzione; inoltre, si segue lo stile Kernighan and Ritchie per quanto riguarda l'utilizzo degli spazi e dei capo-riga;
									\begin{lstlisting}[language=java,captionpos=b,caption={Esempio per la sintassi Java}]
return () -> {
	while (condition()) {
		method();
	}
};

	return new MyClass() {
	@Override public void method() {
		if (condition()) {
			try {
				something();
			} catch (ProblemException e) {
				recover();
			}
		} else if (otherCondition()) {
			somethingElse();
		} else {
			lastThing();
		}
	}
};
									\end{lstlisting}
								\item \textbf{indentazione:} i blocchi del codice devono essere sempre indentati, per ciascun livello, con tabulazione la cui larghezza sia impostata a due (2) spazi; ogni programmatore dovrà configurare il proprio editor di testo secondo questa regola (l'indentazione dei commenti non viene considerata);
								\item \textbf{verbosità:} ogni istruzione non potrà essere più lunga di cento (100) caratteri;
								\item \textbf{univocità dei nomi:} metodi e variabili devono avere nomi univoci che ne descrivano il più possibile la funzione; la prima lettera deve essere sempre minuscola e, nel caso in cui il/la metodo/variabile sia una concatenazione di più parole, i programmatori devo attenersi al \glock{LowerCamelCase}. per quanto riguarda le classi si applicano le regole esposte in precedenza, tranne per la lettera iniziale del nome, che sarà maiuscola, in linea con \glock{UpperCamelCase};

							\end{itemize}
							Ulteriori dettagli sono disponibili alla risorsa online \href{https://google.github.io/styleguide/javaguide.html}{Google Java Style Guide};
						\item \textbf{JavaScript:} si è deciso di seguire le linee guida fornite da \glock{Google} per il linguaggio, in particolare:
							\begin{itemize}
								\item \textbf{parentesizzazione:} le parentesi graffe verranno utilizzate sempre, anche se il corpo del blocco è vuoto o con una sola istruzione; inoltre, si segue lo stile Kernighan and Ritchie per quanto riguarda l'utilizzo degli spazi e dei capo-riga;
								\begin{lstlisting}[language=JavaScript,captionpos=b,caption={Esempio per la sintassi JavaScript}]
class InnerClass {
	constructor() {}

	/** @param {number} foo */
	method(foo) {
		if (condition(foo)) {
			try {
				// Note: this might fail.
				something();
			} catch (err) {
				recover();
			}
		}
	}
}
								\end{lstlisting}
								\item \textbf{indentazione:} i blocchi del codice devono essere indentati, per ciascun livello, con tabulazione la cui larghezza sia impostata a due (2) spazi; ogni programmatore dovrà configurare il proprio editor di testo secondo questa regola (l'indentazione dei commenti non viene considerata);
								\item \textbf{verbosità:} ogni istruzione non potrà essere più lunga di ottanta (80) caratteri;
								\item \textbf{univocità dei nomi:} metodi e variabili devono avere nomi univoci che ne descrivano il più possibile la funzione; la prima lettera deve essere sempre minuscola e, nel caso in cui il/la metodo/variabile sia una concatenazione di più parole, i programmatori devo attenersi al \glock{LowerCamelCase}; per quanto riguarda le classi si applicano le regole esposte in precedenza, tranne per la lettera iniziale del nome, che sarà maiuscola, in linea con \glock{UpperCamelCase};
							\end{itemize}
							Ulteriori dettagli sono disponibili alla risorsa online \href{https://google.github.io/styleguide/jsguide.html}{Google JavaScript Style Guide};
						\item \textbf{PHP:} si è deciso di utilizzare le linee guida fornite dallo standard PSR-12 per il linguaggio, in particolare:
							\begin{itemize}
								\item \textbf{parentesizzazione:} le parentesi graffe verranno utilizzate sempre, anche se il corpo del blocco è vuoto o con una sola istruzione; inoltre, si segue lo stile Kernighan and Ritchie per quanto riguarda l'utilizzo degli spazi e dei capo-riga;
								\begin{lstlisting}[language=php,captionpos=b,caption={Esempio per la sintassi PHP}]
<?php

		declare(strict_types=1);
	
		namespace Vendor\Package;
	
		use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
		use Vendor\Package\SomeNamespace\ClassD as D;
	
		use function Vendor\Package\{functionA, functionB, functionC};
	
		use const Vendor\Package\{ConstantA, ConstantB, ConstantC};
	
		class Foo extends Bar implements FooInterface
		{
				public function sampleFunction(int $a, int $b = null): array
				{
						if ($a === $b) {
								bar();
						} elseif ($a > $b) {
								$foo->bar($arg1);
						} else {
								BazClass::bar($arg2, $arg3);
						}
				}
		
				final public static function bar()
				{
						// method body
				}
		}
								\end{lstlisting}
								\item \textbf{indentazione:} i blocchi del codice devono essere indentati, per ciascun livello, con tabulazione la cui larghezza sia impostata a quattro (4) spazi; ogni programmatore dovrà configurare il proprio editor di testo secondo questa regola (l'indentazione dei commenti non viene considerata);
								\item \textbf{verbosità:} ogni istruzione non potrà essere più lunga di centoventi (120) caratteri;
								\item \textbf{univocità dei nomi:} metodi e variabili devono avere nomi univoci e che ne descrivano il più possibile la funzione; la prima lettera deve essere sempre minuscola e, nel caso in cui il/la metodo/variabile sia una concatenazione di più parole, i programmatori devo attenersi al \glock{LowerCamelCase}; per quanto riguarda le classi si applicano le regole esposte in precedenza tranne per la lettera iniziale del nome, che sarà maiuscola in linea con \glock{UpperCamelCase};
							\end{itemize}
							Ulteriori dettagli sono disponibili alla risorsa online \href{https://www.php-fig.org/psr/psr-12}{PSR PHP Style Guide}.
					\end{itemize}
				
					%\begin{itemize}
					%	\item \textbf{indentazione:} i blocchi del codice devono essere indentati, per ciascun livello, con tabulazione la cui larghezza sia impostata a quattro (4) spazi. Ogni programmatore dovrà configurare il proprio editor di testo secondo questa regola (l'indentazione dei commenti non viene considerata);
						%\item \textbf{univocità dei nomi:} metodi e variabili devono avere nomi univoci e che ne descrivano il più possibile la funzione; la prima lettera deve essere sempre minuscola e, nel caso in cui il metodo/variabile sia una concatenazione di più parole, i programmatori devo attenersi al \glock{CamelCase}.
						%Per quanto riguarda le classi si applicano le regole esposte in precedenza tranne per la lettera iniziale del nome, che sarà maiuscola;
						%\item \textbf{parentesizzazione:} l'uso delle parentesi è obbligatorio per la disambiguazione, sia logica che non, delle operazioni lineari, es. somma, concatenazione in AND, etc.; inoltre, si impone, nell'uso delle parentesi graffe per la definizione di classi e metodi, di concatenare la parentesi di apertura con la stringa di definizione separandola con uno spazio; per quanto riguarda le parentesi tonde esse non dovranno essere separate da alcun spazio e/o indentazione. La stessa politica viene applicata per costrutti di selezione ed iterazione. Sono ammessi, ove applicabili, operatori ternari (per esempio (\textit{(cond1) ? "stringa1" : var1; }) in \textit{PHP}) con la possibilità di non utilizzare le parentesi graffe. Viene riportato un esempio per chiarificare ulteriormente le prescrizioni sopra citate:

						%\begin{lstlisting}[language=java,captionpos=b,caption={Esempio di dichiarazione di una classe in Java}]
							%public class Classe {
							%	private int var1;
							%	private int var2;
							%	private boolean var3;
							%
							%	public void metodo() {
							%		while( true ){
							%	   		if( var1 && ( var2 || var3 ))
							%		  		var1 += var2;
							%			else
							%   				var2 = var1 + var2;
							%		}
							%	}
							%
							%	private int altroMetodo() {
							%		if( var3 ){
							%			return var3;
							%		} else {
							%			return var1 + var2;
							%		}
							%	}
							%}
						%\end{lstlisting}

						%\item \textbf{spazi e capo-riga:} prima di ogni apertura e/o chiusura di parentesi graffa, tonda e quadra ci deve essere uno (1) spazio, fatta eccezione per le parentesi tonde di definizione di metodi. Inoltre, le variabili e simboli dei costrutti lineari dovranno essere separati da uno (1) spazio. Ogni chiusura di parentesi graffa per metodi, classi e condizioni necessita di un capo-riga, fatta eccezione dei costrutti logici \textit{if-else} nei quali la condizione di \textit{else} deve essere separata da uno (1) spazio dalla parentesi graffa di chiusura del costrutto \textit{if}.
					%\end{itemize}


		\subsubsection{Metriche}



% NDR -------------------  METRICHE  ---------------------


		\paragraph{QC-2 Sicurezza}
		\subparagraph{Scopo}
			La sicurezza viene analizzata per fornire al cliente un prodotto che sia privo di vulnerabilità note, sia a livello di librerie, che a livello di contenuti.
		\subparagraph{Introduzione alle Metriche}
			Per la sicurezza si è deciso di utilizzare le seguenti metriche:
			\begin{itemize}
				\item QM-PROD-4 Numero di vulnerabilità rilevate (NVUL);
				\item QM-PROD-5 Tempo di risoluzione vulnerabilità (TVUL).
			\end{itemize}
			\subparagraph{ QM-PROD-4 Numero di vulnerabilità rilevate (NVUL)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica permette di rilevare il numero di vulnerabilità di sicurezza, attraverso \glock{SonarCloud}, per un componente software;
				\item \textbf{Unità di misura: }
					la metrica è espressa con un numero intero;
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato delle rilevazioni ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora non sono state rilevate vulnerabilità nell'applicazione e/o nelle sue dipendenze;
						\item se il risultato è maggiore di 0, allora sono state rilevate vulnerabilità nell'applicazione e/o nelle sue dipendenze.
					\end{itemize}
			\end{itemize}
			\subparagraph{ QM-PROD-5 Tempo di risoluzione vulnerabilità (TVUL) }
			\begin{itemize}
      			\item \textbf{Descrizione: }
					La metrica permette di comprendere la stima temporale per correggere le vulnerabilità di sicurezza rilevate attraverso \glock{SonarCloud}, per un componente software;
				\item \textbf{Unità di misura: }
					La metrica è espressa in minuti;
				\item \textbf{Fonte: }
					Il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					Il risultato delle rilevazioni ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0 allora non sono state scoperte vulnerabilità nell'applicazione e/o nelle sue dipendenze;
						\item se il risultato è maggiore di 0 allora sono state rilevate delle vulnerabilità che hanno un tempo di risoluzione stimato pari a quello riportato.
					\end{itemize}
			\end{itemize}





		\paragraph{QC-3 Affidabilità}
			\subparagraph{Scopo}
				Durante lo sviluppo si vuole monitorare l'affidabilità e la correttezza, così come la sua tolleranza agli errori:
				\begin{itemize}
					\item \textbf{maturità:} il software deve essere in grado di evitare il verificarsi di errori e/o malfunzionamenti derivanti dalla sua esecuzione;
					\item \textbf{tolleranza degli errori:} il prodotto è in grado di mantenere un livello minimo di prestazioni predeterminate anche in presenza di malfunzionamenti e/o usi impropri di esso;
					\item \textbf{recuperabilità:} il software, in seguito ad un errore e/o malfunzionamento, deve essere in grado di ripristinare uno stato di usabilità in un arco di tempo definito e di recuperare eventuali dati persi durante il suddetto lasso di tempo;
					\item \textbf{aderenza:} descrive la capacità del prodotto di aderire alle specifiche relative all'affidabilità.
				\end{itemize}
			\subparagraph{Introduzione alle Metriche}
				Per l'affidabilità si è deciso di utilizzare le seguenti metriche:
				\begin{itemize}
					\item QM-PROD-6 Numero di bug rilevati (BUGR);
					\item QM-PROD-7 Tempo stimato risoluzione bug (TBUG).
				\end{itemize}
			\subparagraph{ QM-PROD-6 Numero di bug rilevati (BUGR)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica permette di rilevare il numero di bug che sono stati scoperti attraverso \glock{SonarCloud}, per un componente software;
				\item \textbf{Unità di misura: }
					la metrica è espressa in numero intero positivo, a partire da 0;
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato delle rilevazioni ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0 allora non sono stati rilevati bug;
						\item se il risultato è maggiore di 0 allora sono stati rilevati dei bug.
					\end{itemize}
			\end{itemize}
			\subparagraph{ QM-PROD-7 Tempo stimato risoluzione bug (TBUG)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica permette di rilevare il tempo stimato per la risoluzione dei bug che sono stati scoperti attraverso \glock{SonarCloud}, per un componente software;
				\item \textbf{Unità di misura: }
					la metrica è espressa in minuti;
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato delle rilevazioni ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0 allora non sono stati rilevati bug;
						\item se il risultato è maggiore di 0 allora sono stati rilevati dei bug che hanno un tempo di risoluzione stimato pari a quello riportato.
					\end{itemize}
			\end{itemize}



		\paragraph{QC-4 Efficienza}
			\subparagraph{Scopo}
				Si vuole misurare l'efficienza del prodotto in modo da fornire all'utente un software usabile, piacevole e veloce:
				\begin{itemize}
					\item \textbf{comportamento nel tempo:} garanzia di tempi di elaborazione accettabili da parte del prodotto;
					\item \textbf{utilizzo di risorse:} utilizzo non eccessivo delle risorse a disposizione.
				\end{itemize}
			\subparagraph{Introduzione alle Metriche}
				Per l'efficienza si è deciso di utilizzare la seguente metrica:
				\begin{itemize}
					\item QM-PROD-8 Risposta media (RM).
				\end{itemize}
			\subparagraph{QM-PROD-8 Risposta media (RM)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica RM punta a misurare l'efficienza di elaborazione del prodotto in modo da fornire all'utente un'esperienza piacevole di utilizzo;
				\item \textbf{Unità di misura: }
					la metrica è espressa millisecondi (\textit{ms});
				\item \textbf{Formula: }
					la formula della metrica è la seguente:
					\[
						\text{RM} = \frac{\sum_{n=1}^{z} \text{tempo di risposta in ms}}{z}
					\]
					dove $z$ è il numero di misurazioni effettuate;
				\item \textbf{Risultato: }
					il risultato della formula indica il tempo medio di risposta del prodotto:
					\begin{itemize}
						\item se è pari a 0, allora non è stata fatta alcuna misurazione poiché non è stato possibile;
						\item se è maggiore di 0, allora è stato possibile eseguire una misurazione.
					\end{itemize}
			\end{itemize}


		\paragraph{QC-5 Usabilità}
			\subparagraph{Scopo}
			Si vuole misurare l'usabilità del prodotto in modo da fornire all'utente un'esperienza piacevole durante il suo utilizzo, nonché fornire un prodotto facile da apprendere ed utilizzare:
			\begin{itemize}
				\item \textbf{comprensibilità:} determina la facilità di utilizzo e di comprensione del prodotto e delle sue funzionalità da parte dell'utente;
				\item \textbf{apprendibilità:} definisce il livello di impegno richiesto, da parte dell'utilizzatore, per imparare ad usare il prodotto;
				\item \textbf{operabilità:} stabilisce il grado con cui il software riesce a mettere il suo utilizzatore in condizione di sfruttare il prodotto per i suoi fini;
				\item \textbf{attrattiva:} la proprietà del software di produrre un'esperienza d'uso gradevole per l'utente.
			\end{itemize}
			\subparagraph{Introduzione alle Metriche}
				Per l'usabilità si è deciso di utilizzare le seguenti metriche:
				\begin{itemize}
					\item QM-PROD-9 Profondità dell'albero delle azioni (PAA);
					\item QM-PROD-10 Profondità dell'albero delle pagine (PAP).
				\end{itemize}
			\subparagraph{QM-PROD-9 Profondità dell'albero delle azioni (PAA)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica PAA permette di misurare l'operabilità e la comprensibilità del prodotto da parte dell'utente; essa misura il numero massimo di azioni effettuate dall'utente prima di poter arrivare al suo obiettivo; viene misurato per il sito web in base alle tipologie di utente previste;
				\item \textbf{Unità di misura: }
					la metrica è espressa con un numero intero;
				\item \textbf{Formula: }
					la formula della metrica è la seguente:
					\textit{PAA = numero di click}
					dove ogni click corrisponde ad un'azione;
				\item \textbf{Risultato: }
					il risultato della formula ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è minore della soglia prevista, allora l'obiettivo potrà essere portato a termine con maggiore semplicità;
						\item se il risultato è maggiore della soglia prevista, allora l'obiettivo potrà essere portato a termine con maggiore difficoltà;
					\end{itemize}
			\end{itemize}
			\subparagraph{QM-PROD-10 Profondità dell'albero delle pagine (PAP)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica PAP permette di misurare l'apprendibilità, l'operabilità e l'attrattiva del prodotto dal punto di vista del cliente; essa misura il numero massimo di pagine visitate dall'utente prima di poter arrivare al suo obiettivo; viene misurato per il sito web in base alle tipologie di utente previste;
				\item \textbf{Unità di misura: }
					la metrica è espressa tramite un numero intero;
				\item \textbf{Formula: }
					la formula della metrica è la seguente:
					\textit{PAP = numero di pagine}
				\item \textbf{Risultato: }
					il risultato della formula ha i seguenti significati:
					\begin{itemize}
						\item un numero minore di pagine, conduce a minore smarrimento dell'utente nel sito;
						\item un numero troppo di alto di pagine, può condurre un maggiore senso di smarrimento dell'utente nel sito.
					\end{itemize}
			\end{itemize}



		\paragraph{QC-6 Manutenibilità}
			\subparagraph{Scopo}
				La manutenibilità viene monitorata per essere in grado di fornire un prodotto modificabile e migliorabile, in modo da poter estendere facilmente sia la vita del prodotto stesso, sia le sue funzionalità.
				\begin{itemize}
					\item \textbf{analizzabilità:} determina la facilità con cui è possibile analizzare e localizzare un errore all'interno del codice;
					\item \textbf{modificabilità:} definisce la capacità del prodotto di apportare una modifica o una estensione;
					\item \textbf{stabilità:} il software deve essere un grado di essere usato anche in caso le modifiche apportate siano errate;
					\item \textbf{testabilità:} determina la capacità del software di essere testato facilmente per fornire una validazione delle modifica apportate.
				\end{itemize}
			\subparagraph{Introduzione alle Metriche}
				Per la manutenibilità si è deciso di utilizzare le seguenti metriche:
				\begin{itemize}
					\item QM-PROD-11 Complessità ciclomatica media (COCIM);
					\item QM-PROD-12 Complessità della classe (CCLA);
					\item QM-PROD-13 Numero di code smell rilevati (NCS);
					\item QM-PROD-14 Tempo di risoluzione code smell (TCS);
					\item QM-PROD-15 Percentuale di duplicazione del Codice (DUPC);
					\item QM-PROD-16 Numero di violazioni standard di codifica (NVSC).
				\end{itemize}
			\subparagraph{QM-PROD-11 Complessità ciclomatica media (COCIM)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica viene usata per rilevare la complessità ciclomatica media di tutte le classi e di tutti i metodi realizzati nel programma; da questa si comprende la quantità delle condizioni realizzate e la loro relativa complessità media;
				\item \textbf{Unità di misura: }
					la metrica è espressa con un numero decimale;
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato rilevato ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora non sono presenti dei punti condizionali del programma;
						\item se il risultato è maggiore di 0, allora il numero di punti condizionali del programma sono un numero finito.
					\end{itemize}
			\end{itemize}
			\subparagraph{QM-PROD-12 Complessità della classe (CCLA)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica CCLA misura il quantitativo medio del numero di metodi presenti nelle classi e permette di comprendere la complessità generale delle stesse;
				\item \textbf{Unità di misura: }
					la metrica è espressa tramite un numero decimale;
				\item \textbf{Formula: }
					la formula della metrica è la seguente:
					\[
				 		CCLA = \frac{\text{numero totale di metodi}}{\text{numero totale di classi}}
				 	\]
				\item \textbf{Risultato: }
					il risultato della formula ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora le classi non hanno metodi;
						\item se il risultato è maggiore di 0, allora in media una classe della componente software ha un numero finito di metodi.
					\end{itemize}
			\end{itemize}
			\subparagraph{QM-PROD-13 Numero di code smell rilevati (NCS)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica viene usata per rilevare il numero di \glock{code smell} attraverso \glock{SonarCloud}; un \glock{code smell} fa riferimento ad una best practice mancata che i programmatori dovrebbero seguire nel corso dello sviluppo per rendere il codice leggibile, privo di errori e manutenibile;
				\item \textbf{Unità di misura: }
					la metrica è espressa tramite un numero intero;
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato rilevato ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora il codice scritto ha rispettato tutte le \textit{best practice} segnalate;
						\item se il risultato è maggiore di 0, allora il codice scritto non ha rispettato tutte le \textit{best practice} segnalate.
					\end{itemize}
			\end{itemize}
			\subparagraph{QM-PROD-14 Tempo di risoluzione code smell (TCS)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica viene usata per rilevare il tempo stimato di risoluzione dei \glock{code smell} attraverso \glock{SonarCloud}; il tempo riportato risulta essere una stima che viene calcolata direttamente da \glock{SonarCloud} sulla base della quantità di \glock{code smell} e della complessità di risoluzione di ognuno di essi;
				\item \textbf{Unità di misura: }
					la metrica è espressa in minuti;
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato rilevato ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora non sono stati trovati \glock{code smell} da risolvere;
						\item se il risultato è maggiore di 0, allora sarà necessario il quantitativo di minuti indicato per risolvere tutti i \glock{code smell} rilevati.
					\end{itemize}
			\end{itemize}
			\subparagraph{QM-PROD-15 Percentuale di duplicazione del codice (DUPC)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica viene usata per rilevare la percentuale di codice duplicato nel corso dello sviluppo;
				\item \textbf{Unità di misura: }
					la metrica è espressa in percentuale (\%);
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso le statistiche di \glock{SonarCloud};
				\item \textbf{Risultato: }
					il risultato rilevato ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora il codice scritto non è stato duplicato su più parti del programma;
						\item se il risultato è maggiore di 0, allora una parte del codice scritto è stato duplicato su più punti del programma.
					\end{itemize}
			\end{itemize}
			\subparagraph{QM-PROD-16 Numero di violazioni dello standard di codifica (NVSC)}
			\begin{itemize}
      			\item \textbf{Descrizione: }
					la metrica viene usata per rilevare il numero di violazioni dello standard di codifica;
				\item \textbf{Unità di misura: }
					la metrica è espressa in percentuale (\%);
				\item \textbf{Fonte: }
					il dato viene recuperato attraverso i report di \textit{Maven} durante la compilazione e tramite \glock{Github Actions};
				\item \textbf{Risultato: }
					il risultato rilevato ha i seguenti significati:
					\begin{itemize}
						\item se il risultato è pari a 0, allora il codice scritto ha rispetto a pieno lo standard di codifica;
						\item se il risultato è maggiore di 0, allora tutto o una parte del codice scritto non ha rispettato lo standard di codifica.
					\end{itemize}
			\end{itemize}



		\paragraph{QP-3 Sviluppo}
			\subparagraph{Scopo}
			Durante lo sviluppo, si vuole monitorare la capacità del prodotto di soddisfare tutti i requisiti richiesti dal proponente per determinare il grado di completamento.

			\subparagraph{Introduzione alle Metriche}
			Per il processo di sviluppo si farà uso delle seguenti metriche:

			\begin{itemize}
				\item QM-PROC-7 Satisfied mandatory requirements (SMR);
				\item QM-PROC-8 Satisfied desirable requirements (SDR);
				\item QM-PROC-9 Satisfied optional requirements (SOR);
				\item QM-PROC-10 Numero di commits (NCOM).
			\end{itemize}

			\subparagraph{QM-PROC-7 Satisfied mandatory requirements (SMR)}

			\begin{itemize}

				\item \textbf{Descrizione: }
				la metrica SMR indica il quantitativo di requisiti obbligatori soddisfatti (progettati, sviluppati e verificati) fino alla data corrente; questa metrica permette sia al gruppo, che al committente, di comprendere la percentuale di completezza base del prodotto;

				\item \textbf{Unità di misura: }
				la metrica viene espressa in percentuale;

				\item \textbf{Formula: }
				la formula della metrica è la seguente:
				\[
					\text{SMR} = \frac{\text{requisiti obbligatori soddisfatti}}{\text{requisiti obbligatori totali}} \times 100
				\]

				\item \textbf{Risultato: }
				\begin{itemize}
					\item un risultato pari a 0\% indica che non è stato soddisfatto ancora alcun requisito obbligatorio;
					\item un risultato superiore allo 0\% ma inferiore al 100\% indica che alcuni requisiti obbligatori sono stati soddisfatti;
					\item un risultato pari a 100\% indica che sono stati soddisfatti tutti i requisiti obbligatori.
				\end{itemize}

			\end{itemize}

			\subparagraph{QM-PROC-8 Satisfied desirable requirements (SDR)}

			\begin{itemize}
      			\item \textbf{Descrizione: }
				la metrica SDR indica il quantitativo di requisiti desiderabili soddisfatti (progettati, sviluppati e verificati) fino alla data corrente; questa metrica permette sia al gruppo, che al committente, di comprendere la percentuale di valore aggiunto del prodotto;

				\item \textbf{Unità di misura: }
				la metrica viene espressa in percentuale;

				\item \textbf{Formula: }
				la formula della metrica è la seguente:
				\[
					\text{SDR} = \frac{\text{requisiti desiderabili soddisfatti}}{\text{requisiti desiderabili totali}} \times 100
				\]

				\item \textbf{Risultato: }
				\begin{itemize}
					\item un risultato pari a 0\% indica che non è stato soddisfatto ancora alcun requisito desiderabile;
					\item un risultato superiore allo 0\% ma inferiore al 100\% indica che alcuni requisiti desiderabili sono stati soddisfatti;
					\item un risultato pari a 100\% indica che sono stati soddisfatti tutti i requisiti desiderabili.
				\end{itemize}
			\end{itemize}

			\subparagraph{QM-PROC-9 Satisfied optional requirements (SOR)}

			\begin{itemize}
      			\item \textbf{Descrizione: }
				la metrica SDR indica il quantitativo di requisiti desiderabili soddisfatti (progettati, sviluppati e verificati) fino alla data corrente;

				\item \textbf{Unità di misura: }
				la metrica viene espressa in percentuale;

				\item \textbf{Formula: }
				la formula della metrica è la seguente:
				\[
					\text{SOR} = \frac{\text{requisiti opzionali soddisfatti}}{\text{requisiti opzionali totali}} \times 100
				\]

				\item \textbf{Risultato: }
				\begin{itemize}
					\item un risultato pari a 0\% indica che non è stato soddisfatto ancora alcun requisito opzionale;
					\item un risultato superiore allo 0\% ma inferiore al 100\% indica che alcuni requisiti opzionali sono stati soddisfatti;
					\item un risultato pari a 100\% indica che sono stati soddisfatti tutti i requisiti opzionali.
				\end{itemize}
			\end{itemize}

			\subparagraph{QM-PROC-10 Numero di commit (NCOM)}

			\begin{itemize}
      			\item \textbf{Descrizione: }
				la metrica mostra il numero di commit che sono stati inseriti nel repository nell'arco di tempo definito;

				\item \textbf{Unità di misura: }
				la metrica viene espressa con un numero intero;

				\item \textbf{Fonte: }
				il dato viene recuperato attraverso le statistiche di \glock{Github};

				\item \textbf{Risultato: }
				\begin{itemize}
					\item un risultato pari a 0 indica che non ci sono stati commit e pertanto il gruppo non ha lavorato;
					\item un risultato superiore a 0 indica che il gruppo ha lavorato attivamente al progetto.
				\end{itemize}
			\end{itemize}



		\subsubsection{Strumenti}
			Di seguito sono elencati gli strumenti che verranno utilizzati nel processo di sviluppo.

				\paragraph{IntelliJ Idea - Ultimate Edition}
					IntelliJ Idea è un IDE sviluppato da \textit{JetBrains} che viene utilizzato per lo sviluppo di applicativi \glock{Java} e permette di agevolare ampiamente lo sviluppatore, grazie agli strumenti aggiuntivi che possono essere facilmente configurati.
					\newline
					Include anche la possibilità di usare un debugger, eseguire refactoring del codice, configurare un sistema di versionamento e integrarsi con i framework più utilizzati per \glock{Java}, come \glock{Spring}.
					\newline
					Il software è a pagamento, ma gratuito per gli studenti universitari.

					\begin{itemize}
						\item IntelliJ Idea genera una cartella \verb!.idea! che non deve essere aggiunta al sistema di versionamento;
						\item analogamente, anche le cartelle di output, \verb!out/! e \verb!target/!, non devono essere versionate.
					\end{itemize}

				\paragraph{PHPStorm}
					PHPStorm è un IDE sviluppato da \textit{JetBrains}, molto simile a IntelliJ Idea, che viene usato per lo sviluppo della web app, la quale fa uso di HTML, PHP e \glock{JavaScript}.
					\newline
					Si integra facilmente con \glock{Laravel} e altri framework molto usati, in particolare permette di configurare tutto in modo automatico, agevolando lo sviluppatore.
					\newline
					PHPStorm è gratuito per gli studenti universitari e può essere riscattato, allo stesso modo di IntelliJ Idea, dal sito ufficiale.

					\begin{itemize}
						\item PHPStorm genera una cartella \verb!.idea! che non deve essere aggiunta al sistema di versionamento;
						\item analogamente, anche le cartelle di output, \verb!out/! e \verb!target/!, non devono essere versionate.
					\end{itemize}

				\paragraph{WebStorm}
					WebStorm è un IDE sviluppato da \textit{JetBrains}, molto simile a PHPStorm, che viene usato per lo sviluppo del \glock{bot Telegram}, il quale fa uso di \glock{JavaScript}.
					\newline
					Si integra facilmente con \glock{Node.js} e altri framework molto usati, in particolare permette di configurare tutto in modo automatico, agevolando lo sviluppatore.
					\newline
					WebStorm è gratuito per gli studenti universitari e può essere riscattato, allo stesso modo di PHPStorm, dal sito ufficiale.

					\begin{itemize}
						\item WebStorm genera una cartella \verb!.idea! che non deve essere aggiunta al sistema di versionamento;
						\item analogamente, anche le cartelle di output, \verb!out/! e \verb!target/!, non devono essere versionate.
					\end{itemize}

				\paragraph{Visual Studio Code}
					Visual Studio Code è un editor di codice sorgente sviluppato da \textit{Microsoft} per Windows, Linux e MacOS; esso include una serie di estensioni che possono essere utilizzate al fine di arricchire l'editor in base alle necessità.
					\newline
					Nell'ambito del progetto, Visual Studio Code può essere utilizzato per lo sviluppo del codice sorgente per board come \glock{Arduino Uno} e \glock{ESP8266}, con le quali è possibile simulare fisicamente un dispositivo industriale.

				\paragraph{Portainer}
					Portainer è un applicativo web usato per la gestione dei \glock{container}, istanziati in una macchina locale o remota, che fa uso di \glock{Docker}.
					\newline
					L'applicativo stesso risulta essere una istanza di un \glock{container}, che può essere installato in qualunque momento. Dal pannello di gestione è possibile:
					\begin{itemize}
						\item aggiungere, modificare e rimuovere container;
						\item avviare, fermare e riavviare container;
						\item visualizzare i logs di un singolo container;
						\item operare dentro il container da riga di comando;
						\item modificare la configurazione di rete e di avvio del container;
						\item aggiungere ed eseguire il processo di build delle \glock{immagini} di \glock{Docker}.
					\end{itemize}

				\paragraph{Kafka Manager}
					Kafka manager è una web app che permette di monitorare e operare sugli stream di \glock{Kafka}.
					\newline
					La web app è facilmente accessibile tramite browser e permette di gestire nel modo più completo ciò che avviene sulle singole istanze di \glock{topic}, verificando effettivamente il funzionamento dell'infrastruttura. Inoltre, è possibile:
					\begin{itemize}
					 	\item creare manualmente nuovi topic;
					 	\item cancellare topic esistenti;
					 	\item aggiornare dei parametri di configurazione di un particolare topic;
					 	\item controllare il flusso di produzione e consumazione dei messaggi.
					 \end{itemize}

				\paragraph{Draw.io}
					Draw.io è un'applicazione online gratuita e collaborativa, utilizzabile nella suite di \glock{Google Drive}, per la realizzazione di diagrammi di molteplici tipologie.
					\newline
					In particolare, risulta molto utile per la rappresentazione di diagrammi UML di qualsiasi tipologia, grazie ad un insieme di forme e figure in linguaggio UML predefinite all'interno dell'applicazione stessa e facilmente componibili per la costruzione dei diagrammi.

				\paragraph{Firefox}
					Browser web sviluppato dalla \textit{Mozilla Foundations} che viene utilizzato per visualizzare la web app e accedere alle interfacce online di \glock{Docker}.
					\newline
					Il browser è gratuito e scaricabile dal sito ufficiale per qualunque sistema operativo.

				\paragraph{Chrome}
					Chrome è un browser web sviluppato da \textit{Google} che viene utilizzato in alternativa a \textit{Firefox}, per la visualizzazione della web app e per accedere agli strumenti online.
					\newline
					Viene utilizzato sia a livello desktop, che a livello mobile, specialmente negli smartphone \textit{Android}.

				\paragraph{Safari}
					Safari è un browser web sviluppato da \textit{Apple} che viene utilizzato per accedere e testare la web app su \textit{MacOs}.
					\newline
					Esiste una versione mobile del browser che viene utilizzata nativamente negli smartphone \textit{Apple}.
